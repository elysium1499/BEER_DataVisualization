<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="generator" content="Observable Framework v1.13.0">
<title>Laboratory One | DataVisualization</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="preload" as="style" href="./_observablehq/theme-air,near-midnight,alt,wide.db1cdf55.css">
<link rel="preload" as="style" href="./_observablehq/stdlib/inputs.ea9fd553.css">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="stylesheet" type="text/css" href="./_observablehq/theme-air,near-midnight,alt,wide.db1cdf55.css">
<link rel="stylesheet" type="text/css" href="./_observablehq/stdlib/inputs.ea9fd553.css">
<link rel="modulepreload" href="./_observablehq/client.6b525bf7.js">
<link rel="modulepreload" href="./_observablehq/runtime.9393ab6d.js">
<link rel="modulepreload" href="./_observablehq/stdlib.3ac83553.js">
<link rel="modulepreload" href="./_node/d3-geo@3.1.1/index.75f0ca91.js">
<link rel="modulepreload" href="./_node/d3-scale@4.0.2/index.09b9abd2.js">
<link rel="modulepreload" href="./_node/d3-scale-chromatic@3.1.0/index.7961cbed.js">
<link rel="modulepreload" href="./_node/d3-zoom@3.0.0/index.93e39acc.js">
<link rel="modulepreload" href="./_observablehq/stdlib/inputs.3e4c82b9.js">
<link rel="modulepreload" href="./_npm/@observablehq/plot@0.6.16/e828d8c8.js">
<link rel="modulepreload" href="./_npm/d3-dsv@3.0.1/407f7a1f.js">
<link rel="modulepreload" href="./_npm/htl@0.3.1/063eb405.js">
<link rel="modulepreload" href="./_npm/isoformat@0.2.1/c68fbd73.js">
<link rel="modulepreload" href="./_node/d3-array@3.2.4/index.f89e3560.js">
<link rel="modulepreload" href="./_node/d3-interpolate@3.0.1/index.7ed7c7fe.js">
<link rel="modulepreload" href="./_node/d3-format@3.1.0/index.75f84505.js">
<link rel="modulepreload" href="./_node/d3-time@3.1.0/index.8fcc123e.js">
<link rel="modulepreload" href="./_node/d3-time-format@4.1.0/index.8a1d2235.js">
<link rel="modulepreload" href="./_node/d3-color@3.1.0/index.e8c126ff.js">
<link rel="modulepreload" href="./_node/d3-dispatch@3.0.1/index.be49ca5f.js">
<link rel="modulepreload" href="./_node/d3-drag@3.0.0/index.8e5f73cc.js">
<link rel="modulepreload" href="./_node/d3-selection@3.0.0/index.13204b25.js">
<link rel="modulepreload" href="./_node/d3-transition@3.0.1/index.d140d658.js">
<link rel="modulepreload" href="./_npm/d3@7.9.0/7055d4c5.js">
<link rel="modulepreload" href="./_npm/interval-tree-1d@1.0.4/a62ae5ce.js">
<link rel="modulepreload" href="./_node/internmap@2.0.3/index.4106013c.js">
<link rel="modulepreload" href="./_node/d3-timer@3.0.1/index.0ee6092b.js">
<link rel="modulepreload" href="./_node/d3-ease@3.0.1/index.09153f73.js">
<link rel="modulepreload" href="./_npm/d3-array@3.2.4/e95f898e.js">
<link rel="modulepreload" href="./_npm/d3-axis@3.0.0/d44feff9.js">
<link rel="modulepreload" href="./_npm/d3-brush@3.0.0/5830b12a.js">
<link rel="modulepreload" href="./_npm/d3-chord@3.0.1/84d7b8e9.js">
<link rel="modulepreload" href="./_npm/d3-color@3.1.0/2c0cdfa2.js">
<link rel="modulepreload" href="./_npm/d3-contour@4.0.2/626bedc4.js">
<link rel="modulepreload" href="./_npm/d3-delaunay@6.0.4/00c41b5d.js">
<link rel="modulepreload" href="./_npm/d3-dispatch@3.0.1/b5f7cdc6.js">
<link rel="modulepreload" href="./_npm/d3-drag@3.0.0/b22c5864.js">
<link rel="modulepreload" href="./_npm/d3-ease@3.0.1/6f15f633.js">
<link rel="modulepreload" href="./_npm/d3-fetch@3.0.1/ef1ec490.js">
<link rel="modulepreload" href="./_npm/d3-force@3.0.0/5e1ff060.js">
<link rel="modulepreload" href="./_npm/d3-format@3.1.0/5851d7ef.js">
<link rel="modulepreload" href="./_npm/d3-geo@3.1.1/dcd02767.js">
<link rel="modulepreload" href="./_npm/d3-hierarchy@3.1.2/f1db2593.js">
<link rel="modulepreload" href="./_npm/d3-interpolate@3.0.1/034b7bcb.js">
<link rel="modulepreload" href="./_npm/d3-path@3.1.0/4bb53638.js">
<link rel="modulepreload" href="./_npm/d3-polygon@3.0.1/bbafde58.js">
<link rel="modulepreload" href="./_npm/d3-quadtree@3.0.1/aa5b35a8.js">
<link rel="modulepreload" href="./_npm/d3-random@3.0.1/32c7fec2.js">
<link rel="modulepreload" href="./_npm/d3-scale@4.0.2/567840a0.js">
<link rel="modulepreload" href="./_npm/d3-scale-chromatic@3.1.0/cf9b720b.js">
<link rel="modulepreload" href="./_npm/d3-selection@3.0.0/5dcd62f4.js">
<link rel="modulepreload" href="./_npm/d3-shape@3.2.0/f8e03c56.js">
<link rel="modulepreload" href="./_npm/d3-time@3.1.0/5bc129e1.js">
<link rel="modulepreload" href="./_npm/d3-time-format@4.1.0/19c92b44.js">
<link rel="modulepreload" href="./_npm/d3-timer@3.0.1/f31b5398.js">
<link rel="modulepreload" href="./_npm/d3-transition@3.0.1/8debb4ba.js">
<link rel="modulepreload" href="./_npm/d3-zoom@3.0.0/4b0cc581.js">
<link rel="modulepreload" href="./_npm/binary-search-bounds@2.0.5/1ee6c50d.js">
<link rel="modulepreload" href="./_npm/internmap@2.0.3/5eed35fd.js">
<link rel="modulepreload" href="./_npm/delaunator@5.0.1/e67acb27.js">
<link rel="modulepreload" href="./_npm/robust-predicates@3.0.2/8ac9039b.js">
<link rel="icon" href="./_file/observable.1af93621.png" type="image/png" sizes="32x32">
<script type="module">

import {define} from "./_observablehq/client.6b525bf7.js";
import {registerFile} from "./_observablehq/stdlib.3ac83553.js";

registerFile("./data/co-emissions-per-capita-filter.csv", {"name":"./data/co-emissions-per-capita-filter.csv","mimeType":"text/csv","path":"./_file/data/co-emissions-per-capita-filter.9f9ae678.csv","lastModified":1731709379255,"size":179331});
registerFile("./data/co2-fossil-plus-land-use.csv", {"name":"./data/co2-fossil-plus-land-use.csv","mimeType":"text/csv","path":"./_file/data/co2-fossil-plus-land-use.f95469a5.csv","lastModified":1732188783030,"size":322449});
registerFile("./data/region_entities.csv", {"name":"./data/region_entities.csv","mimeType":"text/csv","path":"./_file/data/region_entities.6897ee96.csv","lastModified":1731709379265,"size":4099});
registerFile("./data/region_entities_population2022.csv", {"name":"./data/region_entities_population2022.csv","mimeType":"text/csv","path":"./_file/data/region_entities_population2022.b28225e4.csv","lastModified":1731709379265,"size":5856});

define({id: "f920bdb6", inputs: ["FileAttachment"], outputs: ["dataset","RegionDataset","populationDataset","datasetFossil"], body: async (FileAttachment) => {
//column: Entity,Code,Year,Annual COâ‚‚ emissions (per capita)
const dataset = FileAttachment("./data/co-emissions-per-capita-filter.csv").csv({typed: true});
//column: Entity,Region
const RegionDataset = FileAttachment("./data/region_entities.csv").csv({typed: true});
//column: Entity,Region,Population
const populationDataset = FileAttachment("./data/region_entities_population2022.csv").csv({typed: true});
//column: Entity,Region,Code,Year,Annual COâ‚‚ emissions,Annual COâ‚‚ emissions from land-use change,Annual COâ‚‚ emissions from fossil fuel
const datasetFossil = await FileAttachment("./data/co2-fossil-plus-land-use.csv").csv({ typed: true });

return {dataset,RegionDataset,populationDataset,datasetFossil};
}});

define({id: "69f0e69d", inputs: ["dataset","view","Inputs","Plot"], outputs: ["uniqueEntities","year","EmissionsByCapitalYear"], body: (dataset,view,Inputs,Plot) => {
const uniqueEntities = [...new Set(dataset.map(d => d.Year.toString()))].sort((a, b) => b - a);
const year = view(Inputs.select(uniqueEntities, {label: "ðŸ“… Choose Year"}));


function EmissionsByCapitalYear(data, year, { widthÂ =Â 800Â }Â =Â {}) {
  const filteredData = data
    .filter(d => d.Year.toString() === year)
    .map(d => ({
      city: d.Entity,
      co2Emissions: +d["Annual COâ‚‚ emissions (per capita)"]
    }))
    .sort((a, b) => b.co2Emissions - a.co2Emissions)
    .slice(0, 20);

    const colorPalette = [
        "#FFDFBA", // Light Apricot
        "#FFD700", // Gold
        "#FF8C00", // Dark Orange
        "#FF4500", // Orange Red
        "#6B8E23", // Olive Drab
        "#3CB371", // Medium Sea Green
        "#2E8B57", // Sea Green
        "#20B2AA", // Light Sea Green
        "#4682B4", // Steel Blue
        "#4169E1", // Royal Blue
        "#6A5ACD", // Slate Blue
        "#8A2BE2", // Blue Violet
        "#7B68EE", // Medium Slate Blue
        "#A0522D", // Sienna
        "#D2691E", // Chocolate
        "#B22222", // Firebrick
        "#696969", // Dim Gray
        "#A9A9A9", // Dark Gray
    ];

    const coloredData = filteredData.map((cityData, index) => ({
        ...cityData,
        color: colorPalette[index % colorPalette.length]
    }));

    return Plot.plot({
        height: 400,
        width,
        marginLeft: 60,
        marginBottom: 130,
        x: {
            label: "Country",
            domain: coloredData.map(d => d.city),
            tickRotate: -45,
            tickSize: 10 
        },
        y: {
            label: "Annual COâ‚‚ Emissions (per capita) - Billion tons",
            grid: true
        },
        marks: [
            Plot.barY(coloredData, { 
                x: "city", 
                y: "co2Emissions", 
                fill: "color"
            })
        ]
    });
}

return {uniqueEntities,year,EmissionsByCapitalYear};
}});

define({id: "c5890bb6", mode: "inline", inputs: ["resize","EmissionsByCapitalYear","dataset","year","display"], body: async (resize,EmissionsByCapitalYear,dataset,year,display) => {
display(await(
resize((width) => EmissionsByCapitalYear(dataset, year, {width}))
))
}});

define({id: "ce8e7431", inputs: ["Plot"], outputs: ["EmissionsByCapital"], body: (Plot) => {
function EmissionsByCapital(data, { width = 800 } = {}) {
    const totalEmissions = data
        .filter(d => d.Year >= 2011 && d.Year <= 2022)
        .reduce((acc, d) => {
            const city = d.Entity;
            const emissions = +d["Annual COâ‚‚ emissions (per capita)"];

            if (!acc[city]) {
                acc[city] = { city, co2Emissions: 0 };
            }
            acc[city].co2Emissions += emissions;
            return acc;
        }, {});

    const topCities = Object.values(totalEmissions)
        .sort((a, b) => b.co2Emissions - a.co2Emissions)
        .slice(0, 20);

    const uniqueEmissions = [...new Set(topCities.map(d => d.co2Emissions))];

    const colorPalette = [
        "#FFE5B4", // Light Apricot
        "#FFD700", // Gold
        "#FF8C00", // Dark Orange
        "#FF4500", // Orange Red
        "#6B8E23", // Olive Drab
        "#3CB371", // Medium Sea Green
        "#2E8B57", // Sea Green
        "#20B2AA", // Light Sea Green
        "#4682B4", // Steel Blue
        "#4169E1", // Royal Blue
        "#6A5ACD", // Slate Blue
        "#8A2BE2", // Blue Violet
        "#7B68EE", // Medium Slate Blue
        "#A0522D", // Sienna
        "#D2691E", // Chocolate
        "#B22222", // Firebrick
        "#696969", // Dim Gray
        "#A9A9A9", // Dark Gray
    ];

    const emissionColorMap = {};
    uniqueEmissions.forEach((emission, index) => {
        emissionColorMap[emission] = colorPalette[index % colorPalette.length];
    });

    const coloredCities = topCities.map(cityData => ({
        ...cityData,
        color: emissionColorMap[cityData.co2Emissions]
    }));

    return Plot.plot({
        height: 400,
        width,
        marginLeft: 150,
        marginBottom: 60,
        x: {
            label: "Total COâ‚‚ Emissions (per capita) - Billion Tons",
            grid: true,
            nice: true
        },
        y: {
            label: "Country",
            labelPosition: "top",
            domain: coloredCities.map(d => d.city),
            tickRotate: 0
        },
        marks: [
            Plot.barX(coloredCities, { 
                x: "co2Emissions", 
                y: "city", 
                fill: "color"
            })
        ]
    });
}

return {EmissionsByCapital};
}});

define({id: "a24953ee", mode: "inline", inputs: ["resize","EmissionsByCapital","dataset","display"], body: async (resize,EmissionsByCapital,dataset,display) => {
display(await(
resize((width) => EmissionsByCapital(dataset, {width}))
))
}});

define({id: "0ce1d9a3", inputs: ["populationDataset","Plot"], outputs: ["prepareStackedData","EmissionsByRegionStacked"], body: (populationDataset,Plot) => {
function prepareStackedData(data, regionsData) {
  const mergedData = data.filter(d => d.Year === 2022).map(d => {
    const regionData = regionsData.find(region => region.Entity === d.Entity);
    const populationData = populationDataset.find(pop => pop.Entity === d.Entity);
    return {
      city: d.Entity,
      co2Emissions: +d["Annual COâ‚‚ emissions (per capita)"]* (populationData.Population2022)/ 1_000_000_000,
      region: regionData ? regionData.Region : "Unknown"
    };
  });

  return mergedData;
}

function EmissionsByRegionStacked(data, regionsData, { width = 800 } = {}) {
  const preparedData = prepareStackedData(data, regionsData);
  const totalEmissionsByEntity = preparedData.reduce((acc, d) => {
  if (!acc[d.city]) {
    acc[d.city] = { co2Emissions: 0, region: d.region };
  }
    acc[d.city].co2Emissions += d.co2Emissions;
    return acc;
  }, {});

const topCities = Object.values(
  Object.entries(totalEmissionsByEntity)
    .reduce((acc, [city, { co2Emissions, region }]) => {
      if (!acc[region]) acc[region] = [];
      acc[region].push({ city, co2Emissions, region });
      return acc;
    }, {})
).map(citiesInRegion => {
    const sortedCities = citiesInRegion.sort((a, b) => b.co2Emissions - a.co2Emissions);
    const top5Cities = sortedCities.slice(0, 5);
    const otherCitiesSum = sortedCities.slice(5).reduce((sum, city) => sum + city.co2Emissions, 0);
    return [...top5Cities, { city: 'Other Countries', co2Emissions: otherCitiesSum, region: top5Cities[0].region }];
  }).flat();

  const colorPalette = ["#CC564D", "#D4AC40", "#800080", "#4FAAC4", "#008000"];

  const cityColorMap = {};
  topCities.forEach(d => {
    if (d.city === "Other Countries") {
      cityColorMap[d.city] = "#303080";
    } else {
      const cityIndex = topCities.filter(c => c.region === d.region).indexOf(d);
      cityColorMap[d.city] = colorPalette[cityIndex];
    }
  });

  const regionData = {};

  topCities.forEach(d => {
    if (!regionData[d.region]) {
      regionData[d.region] = {
        region: d.region,
        co2Emissions: 0,
        cities: []
      };
    }
    regionData[d.region].co2Emissions += d.co2Emissions;

    if (!regionData[d.region].cities.some(city => city.city === d.city)) {
      regionData[d.region].cities.push({
        city: d.city,
        co2Emissions: d.co2Emissions,
        color: cityColorMap[d.city]
      });
    }
  });

  const finalData = Object.values(regionData).sort((a, b) => b.co2Emissions - a.co2Emissions);

  return Plot.plot({
    width,
    height: 500,
    marginLeft: 100,
    marginBottom: 60,
    x: {
      label: "Total Annual COâ‚‚ Emissions (per capita) - Billion Tons",
      grid: true,
      tickSpacing: 50,
      tickFormat: d => `${d} BT`
    },
    y: {
      label: "Region",
      domain: finalData.map(d => d.region),
      labelPosition: "top"
    },
    marks: [
      Plot.barX(topCities, {
        x: "co2Emissions",
        y: d => d.region,
        fill: d => cityColorMap[d.city],
        title: d => `${d.city}: ${d.co2Emissions.toFixed(4)} Billion Tons of COâ‚‚`,
        tip: true
      })
    ]
  });

}

return {prepareStackedData,EmissionsByRegionStacked};
}});

define({id: "0f6b3f90", mode: "inline", inputs: ["resize","EmissionsByRegionStacked","dataset","RegionDataset","display"], body: async (resize,EmissionsByRegionStacked,dataset,RegionDataset,display) => {
display(await(
resize((width) => EmissionsByRegionStacked(dataset, RegionDataset, { width }))
))
}});

define({id: "e764d8c5", inputs: ["populationDataset","Plot"], outputs: ["colorPalette","prepareData","calculateRegionalEmissions","selectTopCities","rankEmittersByPosition","generateMiniDatasets","applyColorPaletteMiniDatasets","createSubplot","generateLabels","createSubplotContainer","EmissionsByRegionStackedMultiple"], body: (populationDataset,Plot) => {
const colorPalette = ["#CC564D", "#D4AC40", "#800080", "#6B8E23"];

// Step 1: Data Preparation
function prepareData(data, regionsData) {
    return data.map(d => {
        const regionData = regionsData.find(region => region.Entity === d.Entity);
        const populationData = populationDataset.find(pop => pop.Entity === d.Entity);
        return {
            city: d.Entity,
            co2Emissions: +d["Annual COâ‚‚ emissions (per capita)"] * (populationData.Population2022)/ 1_000_000_000,
            region: regionData ? regionData.Region : "Unknown"
        };
    });
}


// Step 2: Calculate total COâ‚‚ emissions for each city within a region
function calculateRegionalEmissions(preparedData) {
    return preparedData.reduce((acc, record) => {
        const { region, city, co2Emissions } = record;

        if (!acc[region]) {
            acc[region] = {};
        }
        if (!acc[region][city]) {
            acc[region][city] = 0;
        }
        acc[region][city] += co2Emissions;
        return acc;
    }, {});
}

function selectTopCities(totalEmissionsByRegion, topN, includeOther = false, includeTotal = false) {
    let topCitiesByRegion = {};

    // Step 1: Build top cities for each region
    for (const region in totalEmissionsByRegion) {
       
        const sortedCities = Object.entries(totalEmissionsByRegion[region])
            .map(([city, co2Emissions]) => ({ city, co2Emissions, region }))
            .filter(cityData => cityData.co2Emissions > 0)
            .sort((a, b) => b.co2Emissions - a.co2Emissions);

        topCitiesByRegion[region] = sortedCities.slice(0, topN);

        const totalEmissions = sortedCities.reduce((sum, city) => sum + city.co2Emissions, 0);
        topCitiesByRegion[region].push({ city: "Total", co2Emissions: totalEmissions, region });
    }

    // Step 2: Sort regions by total emissions in descending order
    const sortedRegions = Object.entries(topCitiesByRegion)
        .map(([region, cities]) => {
            const totalEmissions = cities.reduce((sum, city) => sum + city.co2Emissions, 0);
            return { region, cities, totalEmissions };
        })
        .sort((a, b) => b.totalEmissions - a.totalEmissions);

    // Step 3: Rebuild topCitiesByRegion in sorted order
    topCitiesByRegion = Object.fromEntries(sortedRegions.map(({ region, cities }) => [region, cities]));

    return topCitiesByRegion;
}


// Step 4: Rank emitters by position across regions
function rankEmittersByPosition(topCitiesByRegion) {
    const rankedEmitters = [];
    const maxLength = Math.max(...Object.values(topCitiesByRegion).map(region => region.length));

    for (let position = 0; position < maxLength; position++) {
        const emittersAtPosition = {};

        for (const region in topCitiesByRegion) {
            const cityData = topCitiesByRegion[region][position];
            if (cityData) {
                if (!emittersAtPosition[region]) {
                    emittersAtPosition[region] = [];
                }
                emittersAtPosition[region].push(cityData);
            }
        }

        rankedEmitters.push(emittersAtPosition);
    }

    return rankedEmitters;
}

// Step 5: Generate mini-datasets based on ranked emitters for subplots
function generateMiniDatasets(topCitiesByRegion) {
    const rankedEmitters = rankEmittersByPosition(topCitiesByRegion);
    return rankedEmitters.map((emitters, index) => ({
        rank: index + 1,
        data: emitters
    }));
}

// Step 6: Apply a unique color to each dataset
function applyColorPaletteMiniDatasets(miniDatasets, colorPalette) {
    miniDatasets.forEach((dataset, index) => {
        dataset.color = colorPalette[index % colorPalette.length];
    });
}

// Step 7: Create a single subplot for a mini-dataset with optional text labels and centered x-axis label
function createSubplot(data, orderedRegions, label, width, height, showYAxisLabels, color, showText = true) {
    return Plot.plot({
        width,
        height,
        marginLeft: showYAxisLabels ? 100 : 20,
        marginBottom: 80,
        x: {
            label,
            labelAnchor: "center",
            grid: true,
            tickFormat: "s",
            tickSpacing: 50,
            tickFormat: d => `${d} BT`
        },
        y: {
            domain: orderedRegions,
            label: showYAxisLabels ? "Region" : null,
            labelPosition: "top",
            ticks: showYAxisLabels ? orderedRegions : [],
        },
        marks: [
            Plot.barX(data, {
                x: "co2Emissions",
                y: "region",
                fill: color,
                title: d => `${d.city}: ${d.co2Emissions.toFixed(2)} Billion Tons of COâ‚‚`,
                tip: true
            }),
        ]
    });
}



// Dynamically generate labels based on `topNPerRegion`
function generateLabels(topNPerRegion) {
    const rankLabels = ["First", "Second", "Third"];
    const labels = rankLabels.slice(0, topNPerRegion);
    labels.push("Total emissions");
    return labels;
}

// Step 8: Create container with subplots, applying a unique color for each subplot
function createSubplotContainer(miniDatasets, orderedRegions, width, height, topNPerRegion) {
    const container = document.createElement("div");
    container.style.display = "flex";
    container.style.gap = "20px";

    // Generate appropriate labels
    const labels = generateLabels(topNPerRegion);

    miniDatasets.forEach((dataset, index) => {
        const subplotWidth = index === miniDatasets.length - 1 ? (width / miniDatasets.length) * 2 : width / miniDatasets.length;
        const data = orderedRegions.flatMap(region => dataset.data[region] || []);
        
        const label = labels[index];
        const showYAxisLabels = index === 0;
        const showText = index < miniDatasets.length - 2;
        const subplot = createSubplot(data, orderedRegions, label, subplotWidth, height, showYAxisLabels, dataset.color, showText);
        
        const subplotContainer = document.createElement("div");
        subplotContainer.appendChild(subplot);
        container.appendChild(subplotContainer);
    });

    return container;
}


// Main function to create the full visualization with modularized steps
function EmissionsByRegionStackedMultiple(data, regionsData, { width = 1600, height = 500, topNPerRegion } = {}) {
    // Step 1-3: Data preparation and processing
    const preparedData = prepareData(data, regionsData);
    const regionalEmissions = calculateRegionalEmissions(preparedData);
    const topCitiesByRegion = selectTopCities(regionalEmissions, topNPerRegion, true, true);

    // Step 4-5: Generate mini-datasets based on rankings
    const miniDatasets = generateMiniDatasets(topCitiesByRegion);
    
    // Define orderedRegions after miniDatasets are generated
    const orderedRegions = Object.keys(miniDatasets[miniDatasets.length - 1].data)
        .sort((a, b) => miniDatasets[miniDatasets.length - 1].data[b][0].co2Emissions - miniDatasets[miniDatasets.length - 1].data[a][0].co2Emissions);

    // Step 6: Apply a unique color to each mini-dataset
    applyColorPaletteMiniDatasets(miniDatasets, colorPalette);

    // Step 7-8: Create and return container with subplots
    return createSubplotContainer(miniDatasets, orderedRegions, width, height, topNPerRegion);
}
return {colorPalette,prepareData,calculateRegionalEmissions,selectTopCities,rankEmittersByPosition,generateMiniDatasets,applyColorPaletteMiniDatasets,createSubplot,generateLabels,createSubplotContainer,EmissionsByRegionStackedMultiple};
}});

define({id: "2832f044", mode: "inline", inputs: ["resize","EmissionsByRegionStackedMultiple","dataset","RegionDataset","display"], body: async (resize,EmissionsByRegionStackedMultiple,dataset,RegionDataset,display) => {
display(await(
resize(width => EmissionsByRegionStackedMultiple(dataset, RegionDataset, { width, topNPerRegion: 3 }))
))
}});

define({id: "c3c0d68d", inputs: ["prepareStackedData","Plot"], outputs: ["EmissionsByRegionStackedPercentage"], body: (prepareStackedData,Plot) => {
function EmissionsByRegionStackedPercentage(data, regionsData, { width = 800 } = {}) {
  const preparedData = prepareStackedData(data, regionsData);
  
  const totalEmissionsByEntity = preparedData.reduce((acc, d) => {
    if (!acc[d.city]) {
      acc[d.city] = { co2Emissions: 0, region: d.region };
    }
    acc[d.city].co2Emissions += d.co2Emissions;
    return acc;
  }, {});

  const totalEmissionsByRegion = Object.values(totalEmissionsByEntity).reduce((acc, { co2Emissions, region }) => {
    acc[region] = (acc[region] || 0) + co2Emissions;
    return acc;
  }, {});

  const topCities = Object.values(
    Object.entries(totalEmissionsByEntity)
      .reduce((acc, [city, { co2Emissions, region }]) => {
        if (!acc[region]) acc[region] = [];
        acc[region].push({ city, co2Emissions, region });
        return acc;
      }, {})
  ).map(citiesInRegion => {
      const sortedCities = citiesInRegion.sort((a, b) => b.co2Emissions - a.co2Emissions);
      const top5Cities = sortedCities.slice(0, 5);
      const otherCitiesSum = sortedCities.slice(5).reduce((sum, city) => sum + city.co2Emissions, 0);
      return [
        ...top5Cities, 
        { city: 'Other Countries', co2Emissions: otherCitiesSum, region: top5Cities[0].region }
      ];
    }).flat();

  const colorPalette = ["#CC564D", "#D4AC40", "#800080", "#4FAAC4", "#008000"];

  const cityColorMap = {};
  topCities.forEach(d => {
    if (d.city === "Other Countries") {
      cityColorMap[d.city] = "#303080";
    } else {
      const cityIndex = topCities.filter(c => c.region === d.region).indexOf(d);
      cityColorMap[d.city] = colorPalette[cityIndex];
    }
  });

  const topCitiesWithPercentage = topCities.map(d => ({
    ...d,
    co2EmissionsPercentage: (d.co2Emissions / totalEmissionsByRegion[d.region]) * 100
  }));

  const regionData = {};

  topCitiesWithPercentage.forEach(d => {
    if (!regionData[d.region]) {
      regionData[d.region] = {
        region: d.region,
        co2Emissions: 0,
        cities: []
      };
    }
    regionData[d.region].co2Emissions += d.co2Emissions;

    if (!regionData[d.region].cities.some(city => city.city === d.city)) {
      regionData[d.region].cities.push({
        city: d.city,
        co2EmissionsPercentage: d.co2EmissionsPercentage,
        color: cityColorMap[d.city]
      });
    }
  });

  const finalData = Object.values(regionData).sort((a, b) => b.co2Emissions - a.co2Emissions);

  return Plot.plot({
    width,
    height: 500,
    marginLeft: 100,
    marginBottom: 60,
    x: {
        label: "Percentage of Total Regional COâ‚‚ Emissions",
        tickSpacing: 50,
        tickFormat: d => `${d}%`
    },
    y: {
      label: "Region",
      domain: finalData.map(d => d.region),
      labelPosition: "top"
    },
    marks: [
      Plot.barX(topCitiesWithPercentage, {
        x: "co2EmissionsPercentage",
        y: d => d.region,
        fill: d => cityColorMap[d.city],
        title: d => `${d.city}: ${d.co2EmissionsPercentage.toFixed(2)}% emissions`,
        tip: true
      })
    ]
  });
}


return {EmissionsByRegionStackedPercentage};
}});

define({id: "f17805dc", mode: "inline", inputs: ["resize","EmissionsByRegionStackedPercentage","dataset","RegionDataset","display"], body: async (resize,EmissionsByRegionStackedPercentage,dataset,RegionDataset,display) => {
display(await(
resize((width) => EmissionsByRegionStackedPercentage(dataset, RegionDataset, { width }))
))
}});

define({id: "398d36ac", inputs: ["d3","datasetFossil","Plot"], outputs: ["globalMinEmissions","globalMaxEmissions","prepareDataForYear","renderHeatmap","initializeDropdown","autoPlayInterval","toggleAutoPlay"], body: (d3,datasetFossil,Plot) => {
// Prepare the data for the heatmap based on the selected year and top countries
const globalMinEmissions = 0; // Assuming COâ‚‚ emissions can't be negative
const globalMaxEmissions = d3.max(datasetFossil, d => +d["Annual COâ‚‚ emissions"]) / 1e9;

function prepareDataForYear(data, year) {
  return data
    .filter(d => d.Year === year)
    .map(d => ({
      country: d.Entity,
      region: d.Region,
      year,
      fossilEmissions: +d["Annual COâ‚‚ emissions from fossil fuel"] / 1e9,       // Normalizing to million tons
      landUseEmissions: +d["Annual COâ‚‚ emissions from land-use change"] / 1e9, // Normalizing to million tons
      totalEmissions: +d["Annual COâ‚‚ emissions"] / 1e9 // Total emissions
    }))
    .sort((a, b) => b.totalEmissions - a.totalEmissions) // Sort by total emissions
    .slice(0, 10) // Top 10 countries by total emissions
    .flatMap(d => [
      { country: d.country, yearAndType: `${year} (Fossil Fuel)`, emissions: d.fossilEmissions },
      { country: d.country, yearAndType: `${year} (Land-Use)`, emissions: d.landUseEmissions },
      { country: d.country, yearAndType: `${year} (Total)`, emissions: d.totalEmissions } // Add total emissions
    ]);
}

// Generate and render the heatmap based on the selected year
function renderHeatmap(data, year) {
  const heatmapData = prepareDataForYear(data, year);
  const heatmap = Plot.plot({
    width: 1000, // Increase width for bigger cells
    height: 300, // Increase height for bigger cells
    marginLeft: 150,
    marginBottom: 100,
    marginTop: 50,
    style: {
      fontSize: "14px", // Keep font size readable
      color: "white"
    },
    x: {
      label: "Country",
      domain: [...new Set(heatmapData.map(d => d.country))],
      tickRotate: -30,
      labelAnchor: "center",
      paddingInner: 0.1 // Adjust spacing between columns for bigger cells
    },
    y: {
      label: "Year and Emission Type",
      domain: [`${year} (Fossil Fuel)`, `${year} (Land-Use)`, `${year} (Total)`],
      paddingInner: 0.1 // Adjust spacing between rows for bigger cells
    },
    color: {
      type: "linear",
      domain: [globalMinEmissions, globalMaxEmissions], // Use global domain for fixed legend
      scheme: "reds",
      label: "COâ‚‚ Emissions (billion tons)",
      legend: true
    },
    marks: [
      Plot.rect(heatmapData, { 
        x: "country", 
        y: "yearAndType", 
        fill: "emissions", 
        title: d => `${d.country}: ${d.emissions.toFixed(2)} billion tons`,
        tip: true,
        stroke: "black",
        strokeWidth: 0.1
      })
    ]
  });
  document.getElementById("heatmap-container").innerHTML = ""; // Clear previous plot
  document.getElementById("heatmap-container").appendChild(heatmap); // Append new plot
}


// Initialize the dropdown menu and initial heatmap
function initializeDropdown(data) {
  const years = [...new Set(data.map(d => d.Year))].sort((a, b) => a - b);
  const dropdown = document.getElementById("year-dropdown");
  dropdown.onchange = () => renderHeatmap(data, Number(dropdown.value));

  years.forEach(year => {
    const option = document.createElement("option");
    option.value = year;
    option.text = year;
    dropdown.appendChild(option);
  });

  renderHeatmap(data, years[0]); // Render the heatmap for the initial year
}

// Auto-play functionality to cycle through years
let autoPlayInterval;

function toggleAutoPlay(data) {
  const dropdown = document.getElementById("year-dropdown");
  const years = [...dropdown.options].map(option => Number(option.value));
  let currentIndex = years.indexOf(Number(dropdown.value));

  if (autoPlayInterval) {
    // Stop auto-play if it's already running
    clearInterval(autoPlayInterval);
    autoPlayInterval = null;
    document.getElementById("auto-play-button").innerText = "Auto Play";
  } else {
    // Start auto-play
    autoPlayInterval = setInterval(() => {
      // Check if the next year is greater than the current year
      const previousYear = years[currentIndex];
      currentIndex = (currentIndex + 1) % years.length;
      const currentYear = years[currentIndex];

      if (currentYear <= previousYear) {
        // Stop auto-play if the year does not increase
        clearInterval(autoPlayInterval);
        autoPlayInterval = null;
        document.getElementById("auto-play-button").innerText = "Auto Play";
      } else {
        // Update dropdown and heatmap with the new year
        dropdown.value = currentYear;
        renderHeatmap(data, currentYear);
      }
    }, 350); // Change year every 1 second
    document.getElementById("auto-play-button").innerText = "Stop";
  }
}

// Attach the toggleAutoPlay function to the button
document.getElementById("auto-play-button").onclick = () => toggleAutoPlay(datasetFossil);

// Call the initialize function with the dataset
initializeDropdown(datasetFossil);
return {globalMinEmissions,globalMaxEmissions,prepareDataForYear,renderHeatmap,initializeDropdown,autoPlayInterval,toggleAutoPlay};
}});

define({id: "7c4f44f2", inputs: ["datasetFossil"], outputs: ["d3","sankey","sankeyLinkHorizontal","dataYear2000","ContinentCountryEmissionSankeyChart"], body: async (datasetFossil) => {
// Import necessary D3 libraries
const [d3, { sankey, sankeyLinkHorizontal }] = await Promise.all([
  import("https://cdn.jsdelivr.net/npm/d3@7/+esm"),
  import("https://cdn.jsdelivr.net/npm/d3-sankey@0.12/+esm")
]);


// Filter data for the year 2000 and select top 30 countries by COâ‚‚ emissions
const dataYear2000 = datasetFossil
  .filter(d => d.Year === 2000)  // Filter for the year 2000
  .sort((a, b) => b["Annual COâ‚‚ emissions"] - a["Annual COâ‚‚ emissions"])  // Sort by emissions, descending
  .slice(0, 30);  // Select top 30 countries
console.log("Data for year 2000:", dataYear2000);  // Check filtered data

// Define the chart function to connect continents to countries and countries to emission types
function ContinentCountryEmissionSankeyChart(data, width, height = 600) {
  const continentNodes = [];  // Layer 1: Continent nodes
  const countryNodes = [];    // Layer 2: Country nodes
  const typeNodes = [{ name: "Fossil Use" }, { name: "Land Use" }];  // Layer 3: Emission types
  const links = [];

  // Step 1: Create unique continent nodes
  const uniqueContinents = Array.from(new Set(data.map(d => d.Region)));
  uniqueContinents.forEach(continent => {
    continentNodes.push({ name: continent });
  });

  // Step 2: Create country nodes and links from continent to country
  data.forEach(d => {
    const countryName = d.Entity;
    const continentName = d.Region;

    // Add country node if it doesn't exist
    if (!countryNodes.some(node => node.name === countryName)) {
      countryNodes.push({ name: countryName });
    }

    // Create link from continent to country based on total emissions
    links.push({
      source: continentName,
      target: countryName,
      value: d["Annual COâ‚‚ emissions"]
    });
  });

  // Step 3: Link each country to "Fossil Use" and "Land Use" nodes for specific emission types
  data.forEach(d => {
    const countryName = d.Entity;

    // Link to Fossil emissions if applicable
    if (d["Annual COâ‚‚ emissions from fossil fuel"] > 0) {
      links.push({
        source: countryName,
        target: "Fossil Use",
        value: d["Annual COâ‚‚ emissions from fossil fuel"]
      });
    }

    // Link to Land Use emissions if applicable
    if (d["Annual COâ‚‚ emissions from land-use change"] > 0) {
      links.push({
        source: countryName,
        target: "Land Use",
        value: d["Annual COâ‚‚ emissions from land-use change"]
      });
    }
  });

  // Combine nodes for Sankey setup
  const nodes = [...continentNodes, ...countryNodes, ...typeNodes];

  // Set up the Sankey diagram
  const color = d3.scaleOrdinal(d3.schemeCategory10);

  const { nodes: sankeyNodes, links: sankeyLinks } = sankey()
    .nodeWidth(30)
    .nodePadding(7)
    .extent([[1, 1], [width - 1, height - 6]])({
      nodes: nodes.map(d => ({ ...d })),
      links: links.map(d => ({
        source: nodes.findIndex(n => n.name === d.source),
        target: nodes.findIndex(n => n.name === d.target),
        value: d.value
      }))
    });

  // Create an SVG element
  const svg = d3.create("svg")
    .attr("viewBox", [-30, -30, width , height])
    .attr("width", width -50)
    .attr("height", height)
    .style("min-height", "640px")
    .style("font", "10px sans-serif");

  // Create a tooltip div that is hidden by default
  const tooltip = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("position", "absolute")
    .style("background", "rgba(0, 0, 0, 0.7)")
    .style("color", "white")
    .style("padding", "5px 10px")
    .style("border-radius", "4px")
    .style("font-size", "12px")
    .style("pointer-events", "none")
    .style("display", "none");

  svg.append("g")
    .selectAll("rect")
    .data(sankeyNodes)
    .join("rect")
    .attr("x", d => d.x0)
    .attr("y", d => d.y0)
    .attr("height", d => d.y1 - d.y0)
    .attr("width", d => d.x1 - d.x0)
    .attr("fill", d => color(d.name))
    .style("opacity", 0.7)
    .on("mouseover", function(event, d) {
      d3.select(this).style("opacity", 1);
      tooltip.style("display", "block")
        .html(`<strong>${d.name}</strong>`);
    })
    .on("mousemove", event => {
      tooltip.style("top", `${event.pageY + 10}px`)
        .style("left", `${event.pageX + 10}px`);
    })
    .on("mouseout", function() {
      d3.select(this).style("opacity", 0.7);
      tooltip.style("display", "none");
    });

  svg.append("g")
  .attr("fill", "none")
  .selectAll("path")
  .data(sankeyLinks)
  .join("path")
  .attr("d", sankeyLinkHorizontal())
  .attr("stroke", d => color(d.source.name))
  .attr("stroke-width", d => Math.max(1, d.width))
  .attr("opacity", 0.5)
  .on("mouseover", function(event, d) {
    d3.select(this).attr("opacity", 0.8);

    // Verifica il tipo di collegamento basandosi sui nodi di origine e destinazione
    if (continentNodes.some(node => node.name === d.source.name) &&
        countryNodes.some(node => node.name === d.target.name)) {
        tooltip.style("display", "block").html(`<strong>${d.source.name} â†’ ${d.target.name}</strong>`);
    } else if (countryNodes.some(node => node.name === d.source.name) && typeNodes.some(node => node.name === d.target.name)) {
        tooltip.style("display", "block").html(`<strong>${d.source.name} â†’ Value: ${(d.value / 1_000_000_000).toLocaleString()} BT </strong>`);
    }
  })
  .on("mousemove", event => {
    tooltip.style("top", `${event.pageY + 10}px`)
      .style("left", `${event.pageX + 10}px`);
  })
  .on("mouseout", function() {
    d3.select(this).attr("opacity", 0.5);
    tooltip.style("display", "none");
  });

  svg.append("text")
    .attr("x", 0)
    .attr("y", -20)
    .attr("text-anchor", "start")
    .style("font-weight", "bold")
    .style("fill", "white")
    .style("font-size", "16px")
    .text("Region");

  svg.append("text")
    .attr("x", width * 0.5)
    .attr("y", -20)
    .attr("text-anchor", "middle")
    .style("font-weight", "bold")
    .style("fill", "white")
    .style("font-size", "16px")
    .text("Country");

  svg.append("text")
    .attr("x", width)
    .attr("y", -20)
    .attr("text-anchor", "end")
    .style("font-weight", "bold")
    .style("fill", "white")
    .style("font-size", "16px")
    .text("Emission");

  return svg.node();

}

return {d3,sankey,sankeyLinkHorizontal,dataYear2000,ContinentCountryEmissionSankeyChart};
}});

define({id: "40e98c05", mode: "inline", inputs: ["resize","ContinentCountryEmissionSankeyChart","dataYear2000","display"], body: async (resize,ContinentCountryEmissionSankeyChart,dataYear2000,display) => {
display(await(
resize((width) =>ContinentCountryEmissionSankeyChart(dataYear2000, width))
))
}});

define({id: "6530913e", inputs: ["FileAttachment","d3"], outputs: ["geoMercator","geoPath","scaleSequential","interpolateYlOrRd","zoom","createCO2EmissionsMap"], body: async (FileAttachment,d3) => {
const [{geoMercator, geoPath}, {scaleSequential}, {interpolateYlOrRd}, {zoom}] = await Promise.all([import("./_node/d3-geo@3.1.1/index.75f0ca91.js"), import("./_node/d3-scale@4.0.2/index.09b9abd2.js"), import("./_node/d3-scale-chromatic@3.1.0/index.7961cbed.js"), import("./_node/d3-zoom@3.0.0/index.93e39acc.js")]);
//import * as d3 from "d3";

async function createCO2EmissionsMap(containerId) {
  // Carica i dataset
  const co_emissions_per_capita = await FileAttachment("./data/co-emissions-per-capita-filter.csv").csv({ typed: true });
  const region_population = await FileAttachment("./data/region_entities_population2022.csv").csv({ typed: true });

  // Mappa per corrispondenza dei nomi dei paesi
  const countryNameMapping = {
    "USA": "United States",
    "England": "United Kingdom",
    "Czech Republic": "Czechia",
    "Republic of Serbia": "Serbia",
    "Guinea Bissau": "Guinea-Bissau",
    "Macedonia": "North Macedonia",
    "Ivory Coast": "Cote d'Ivoire",
    "Somaliland": "Somalia",
    "Republic of the Congo": "Congo",
    "Democratic Republic of the Congo": "Congo",
    "United Republic of Tanzania": "Tanzania",
    "The Bahamas": "Bahamas"
  };
  // Trasforma il dataset della popolazione in una mappa
  const populationMap = new Map(region_population.map(d => [d.Entity, d.Population2022]));

  // Calcola le emissioni totali per ogni paese
  const emissionsWithPopulation = co_emissions_per_capita
    .filter(d => d.Year === 2022)
    .map(d => {
      let countryName = d.Entity;
      countryName = countryNameMapping[countryName] || countryName;

      const population = populationMap.get(countryName);
      const totalEmissions = population ? d["Annual COâ‚‚ emissions (per capita)"] * population : null;
      return {
        ...d,
        Population: population,
        TotalEmissions: totalEmissions,
      };
    });

  // Ordina i paesi per emissioni totali
  const topEmissions = emissionsWithPopulation.sort((a, b) => (b.TotalEmissions || 0) - (a.TotalEmissions || 0));

  // URL del file GeoJSON
  const url = "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson";
  const worldData = await fetch(url).then(response => response.json());

  // Crea una mappa delle emissioni totali
  const emissionMap = new Map(topEmissions.map(d => [d.Entity, d.TotalEmissions]));

  // Aggiorna il GeoJSON con i dati
  const countriesWithEmissions = worldData.features.map(feature => {
    let countryName = feature.properties.name;
    countryName = countryNameMapping[countryName] || countryName;

    const emission = emissionMap.get(countryName);
    feature.properties.emission = emission;
    return feature;
  });

  // Dimensioni del contenitore
  const container = d3.select("#" + containerId);
  const width = container.node().clientWidth;
  const height = container.node().clientHeight;

  // Proiezione e path
  const projection = d3.geoMercator()
    .scale(140)
    .translate([width / 2, height / 1.5]);

  const path = geoPath().projection(projection);

  // Scala colori basata sulle emissioni totali
  const maxEmission = d3.max(topEmissions, d => d.TotalEmissions);
  const colorScale = scaleSequential(interpolateYlOrRd).domain([0, maxEmission]);

  // SVG e gruppo mappa
  const svg = container.append("svg")
    .attr("width", width)
    .attr("height", height);

  const mapGroup = svg.append("g");

  // Funzione di formattazione personalizzata
  function customFormat(value) {
    return (value / 1e4).toFixed(2) + " Gigatons";
  }

  // Disegna la mappa
  mapGroup.selectAll("path")
    .data(countriesWithEmissions)
    .join("path")
    .attr("d", path)
    .attr("fill", d => {
      const emissions = d.properties.emission;
      return emissions ? colorScale(emissions) : "#ccc";
    })
    .attr("stroke", "white")
    .attr("stroke-width", 0.5)
    .append("title")
    .text(d => {
      const emissions = d.properties.emission;
      return `${d.properties.name}: ${emissions ? customFormat(emissions) : "No data"}`;
    });

  // Zoom e pan
  const zoomHandler = zoom()
    .scaleExtent([1, 8])
    .translateExtent([[-width, -height], [2 * width, 2 * height]])
    .on("zoom", (event) => {
      mapGroup.attr("transform", event.transform);
    });

  svg.call(zoomHandler);

  // Aggiungi la legenda
  const legendWidth = 300;
  const legendHeight = 20;

  const legendGroup = svg.append("g")
    .attr("transform", `translate(${(width - legendWidth) / 2}, ${height - 50})`);

  const legendScale = d3.scaleLinear()
    .domain([0, maxEmission])
    .range([0, legendWidth]);

  const defs = svg.append("defs");
  const linearGradient = defs.append("linearGradient")
    .attr("id", "legend-gradient");

  linearGradient.selectAll("stop")
    .data(colorScale.ticks(10).map((t, i, n) => ({
      offset: `${(100 * i) / (n.length - 1)}%`,
      color: colorScale(t)
    })))
    .join("stop")
    .attr("offset", d => d.offset)
    .attr("stop-color", d => d.color);

  legendGroup.append("rect")
    .attr("width", legendWidth)
    .attr("height", legendHeight)
    .style("fill", "url(#legend-gradient)");

  legendGroup.append("g")
    .attr("transform", `translate(0, ${legendHeight})`)
    .call(d3.axisBottom(legendScale)
      .ticks(3)
      .tickFormat(d => customFormat(d)))
    .select(".domain").remove();
}

// Crea la mappa
createCO2EmissionsMap("chart-container");


return {geoMercator,geoPath,scaleSequential,interpolateYlOrRd,zoom,createCO2EmissionsMap};
}});

define({id: "ad3a78a4", inputs: ["FileAttachment","d3"], outputs: ["geoOrthographic","geoPath","scaleSequential","interpolateYlOrRd","zoom","countryNameMapping","createCO2EmissionsMap"], body: async (FileAttachment,d3) => {
const [{geoOrthographic, geoPath}, {scaleSequential}, {interpolateYlOrRd}, {zoom}] = await Promise.all([import("./_node/d3-geo@3.1.1/index.75f0ca91.js"), import("./_node/d3-scale@4.0.2/index.09b9abd2.js"), import("./_node/d3-scale-chromatic@3.1.0/index.7961cbed.js"), import("./_node/d3-zoom@3.0.0/index.93e39acc.js")]);
//import * as d3 from "d3";

  // Mappa per corrispondenza dei nomi dei paesi
  const countryNameMapping = {
    "USA": "United States",
    "England": "United Kingdom",
    "Czech Republic": "Czechia",
    "Republic of Serbia": "Serbia",
    "Guinea Bissau": "Guinea-Bissau",
    "Macedonia": "North Macedonia",
    "Ivory Coast": "Cote d'Ivoire",
    "Somaliland": "Somalia",
    "Republic of the Congo": "Congo",
    "Democratic Republic of the Congo": "Congo",
    "United Republic of Tanzania": "Tanzania",
    "The Bahamas": "Bahamas"
  };

async function createCO2EmissionsMap(containerId) {
  // Carica i dataset
  const co_emissions_per_capita = await FileAttachment("./data/co-emissions-per-capita-filter.csv").csv({ typed: true });
  const region_population = await FileAttachment("./data/region_entities_population2022.csv").csv({ typed: true });

  // Trasforma il dataset della popolazione in una mappa
  const populationMap = new Map(region_population.map(d => [d.Entity, d.Population2022]));

  // Calcola le emissioni totali per ogni paese
  const emissionsWithPopulation = co_emissions_per_capita
    .filter(d => d.Year === 2022)
    .map(d => {
      let countryName = d.Entity;
      countryName = countryNameMapping[countryName] || countryName;

      const population = populationMap.get(countryName);
      const totalEmissions = population ? d["Annual COâ‚‚ emissions (per capita)"] * population : null;
      return {
        ...d,
        Population: population,
        TotalEmissions: totalEmissions,
      };
    });

  // Ordina i paesi per emissioni totali
  const topEmissions = emissionsWithPopulation.sort((a, b) => (b.TotalEmissions || 0) - (a.TotalEmissions || 0));

  // URL del file GeoJSON
  const url = "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson";
  const worldData = await fetch(url).then(response => response.json());

  // Crea una mappa delle emissioni totali
  const emissionMap = new Map(topEmissions.map(d => [d.Entity, d.TotalEmissions]));

  // Aggiorna il GeoJSON con i dati
  const countriesWithEmissions = worldData.features.map(feature => {
    let countryName = feature.properties.name;
    countryName = countryNameMapping[countryName] || countryName;

    const emission = emissionMap.get(countryName);
    feature.properties.totalEmission = emission;
    return feature;
  });

  // Dimensioni del contenitore
  const container = d3.select("#" + containerId);
  const width = container.node().clientWidth;
  const height = container.node().clientHeight;

  // Proiezione e path
  const projection = geoOrthographic()
    .scale(200)
    .translate([width / 2, height / 2]);

  const path = geoPath().projection(projection);

  // Scala colori basata sulle emissioni totali
  const maxEmission = d3.max(topEmissions, d => d.TotalEmissions);
  const colorScale = scaleSequential(interpolateYlOrRd).domain([0, maxEmission]);

  // SVG e gruppo mappa
  const svg = container.append("svg")
    .attr("width", width)
    .attr("height", height);

  const mapGroup = svg.append("g");

  // Funzione di formattazione personalizzata
  function customFormat(value) {
    if (value >= 1e4) return (value / 1e4).toFixed(2) + " Giga tons";
    return value.toFixed(2) + " Gigatons";
  }

  // Disegna la mappa
  mapGroup.selectAll("path")
    .data(countriesWithEmissions)
    .join("path")
    .attr("d", path)
    .attr("fill", d => {
      const emissions = d.properties.totalEmission;
      return emissions ? colorScale(emissions) : "#ccc";
    })
    .attr("stroke", "white")
    .attr("stroke-width", 0.5)
    .append("title")
    .text(d => {
      const emissions = d.properties.totalEmission;
      return `${d.properties.name}: ${emissions ? customFormat(emissions) : "No data"}`;
    });

  // Trascinamento per ruotare il globo
  let rotate = [0, 0];
  let isDragging = false;
  let lastPosition = null;

  svg.on("mousedown", (event) => {
    isDragging = true;
    lastPosition = [event.clientX, event.clientY];
  });

  svg.on("mousemove", (event) => {
    if (isDragging) {
      const [dx, dy] = [event.clientX - lastPosition[0], event.clientY - lastPosition[1]];
      rotate[0] += dx / 5;
      rotate[1] -= dy / 5;
      projection.rotate(rotate);
      mapGroup.selectAll("path").attr("d", path);
      lastPosition = [event.clientX, event.clientY];
    }
  });

  svg.on("mouseup", () => {
    isDragging = false;
  });

  svg.on("mouseleave", () => {
    isDragging = false;
  });

  // Zoom per ingrandire/rimpicciolire
  const zoomHandler = zoom()
    .scaleExtent([0.5, 8]) // Zoom minimo e massimo
    .on("zoom", (event) => {
      mapGroup.attr("transform", event.transform);
    });

  svg.call(zoomHandler);

  // Aggiungi la legenda
  const legendWidth = 300;
  const legendHeight = 20;

  const legendGroup = svg.append("g")
    .attr("transform", `translate(${(width - legendWidth) / 2}, ${height - 50})`);

  const legendScale = d3.scaleLinear()
    .domain([0, maxEmission])
    .range([0, legendWidth]);

  const defs = svg.append("defs");
  const linearGradient = defs.append("linearGradient")
    .attr("id", "legend-gradient");

  linearGradient.selectAll("stop")
    .data(colorScale.ticks(20).map((t, i, n) => ({
      offset: `${(100 * i) / (n.length - 1)}%`,
      color: colorScale(t)
    })))
    .join("stop")
    .attr("offset", d => d.offset)
    .attr("stop-color", d => d.color);

  legendGroup.append("rect")
    .attr("width", legendWidth)
    .attr("height", legendHeight)
    .style("fill", "url(#legend-gradient)");

  legendGroup.append("g")
    .attr("transform", `translate(0, ${legendHeight})`)
    .call(d3.axisBottom(legendScale)
      .ticks(3)
      .tickFormat(d => customFormat(d)))
    .select(".domain").remove();
}

// Crea la mappa
createCO2EmissionsMap("chart-container");

return {geoOrthographic,geoPath,scaleSequential,interpolateYlOrRd,zoom,countryNameMapping,createCO2EmissionsMap};
}});

</script>
</head>
<body>
<input id="observablehq-sidebar-toggle" type="checkbox" title="Toggle sidebar">
<label id="observablehq-sidebar-backdrop" for="observablehq-sidebar-toggle"></label>
<nav id="observablehq-sidebar">
  <ol>
    <label id="observablehq-sidebar-close" for="observablehq-sidebar-toggle"></label>
    <li class="observablehq-link"><a href="./">DataVisualization</a></li>
  </ol>
  <ol>
    <li class="observablehq-link observablehq-link-active"><a href="./laboratory1">Laboratory One</a></li>
  </ol>
</nav>
<script>{const e=document.querySelector("#observablehq-sidebar"),t=document.querySelector("#observablehq-sidebar-toggle"),r=sessionStorage.getItem("observablehq-sidebar");r?t.checked=r==="true":t.indeterminate=!0;for(const o of document.querySelectorAll("#observablehq-sidebar summary")){const s=o.parentElement;switch(sessionStorage.getItem(`observablehq-sidebar:${o.textContent}`)){case"true":s.open=!0;break;case"false":s.classList.contains("observablehq-section-active")||(s.open=!1);break}}addEventListener("beforeunload",()=>sessionStorage.setItem("observablehq-sidebar-scrolly",`${e.scrollTop}`));const a=sessionStorage.getItem("observablehq-sidebar-scrolly");a!=null&&(e.style.cssText="overflow: hidden;",e.scrollTop=+a,e.style.cssText="");}</script>
<div id="observablehq-center">
<aside id="observablehq-toc" data-selector="h1:not(:first-of-type)[id], h2:first-child[id], :not(h1) + h2[id]">
<nav>
<div>Contents</div>
<ol>
<li class="observablehq-secondary-link"><a href="#exploring-data">Exploring data</a></li>
<li class="observablehq-secondary-link"><a href="#country-comparison-per-region-in-2022">Country Comparison per Region in 2022</a></li>
<li class="observablehq-secondary-link"><a href="#co-emissions-comparison-per-type-fossil-land-use">COâ‚‚ emissions comparison per type (fossil/land-use)</a></li>
<li class="observablehq-secondary-link"><a href="#section-2-alluvial">Section 2: Alluvial</a></li>
<li class="observablehq-secondary-link"><a href="#data-and-chart-setup">Data and Chart Setup</a></li>
<li class="observablehq-secondary-link"><a href="#co-emissions-map">COâ‚‚ Emissions Map ðŸŒ</a></li>
<li class="observablehq-secondary-link"><a href="#plot-2">Plot 2</a></li>
</ol>
</nav>
</aside>
<main id="observablehq-main" class="observablehq">
<!-- Load the data -->
<div class="observablehq observablehq--block"><!--:f920bdb6:--></div>
<!-- BarPlot that show the emission and the country in one year -->
<h1 id="section-1-co-emissions" tabindex="-1"><a class="observablehq-header-anchor" href="#section-1-co-emissions">Section 1: COâ‚‚ emissions</a></h1>
<br>
<h2 id="exploring-data" tabindex="-1"><a class="observablehq-header-anchor" href="#exploring-data">Exploring data</a></h2>
<br>
<h3 id="top-20-countries-with-high-co-emissions-per-capita-in-the-years" tabindex="-1"><a class="observablehq-header-anchor" href="#top-20-countries-with-high-co-emissions-per-capita-in-the-years">Top 20 Countries with high COâ‚‚ Emissions Per Capita in the Years ðŸŒ</a></h3>
<div class="observablehq observablehq--block"><!--:69f0e69d:--></div>
<div class="grid grid-cols-1"> 
  <div class="card"> <observablehq-loading></observablehq-loading><!--:c5890bb6:--> </div> 
</div>
<p> 
</p><p>Countries like <strong>Qatar</strong>, <strong>United Arab Emirates (UAE)</strong>, and <strong>Kuwait</strong> lead with exceptionally high emissions per capita, primarily due to their reliance on fossil fuel extraction and export.</p>
<p><strong>Australia</strong>, <strong>United States</strong>, and <strong>Canada</strong> follow closely, with emissions shaped by their high energy consumption, large geographical areas, and industrial economies.</p>
<p>Despite their small populations, <strong>Trinidad and Tobago</strong> and <strong>New Caledonia</strong> also have high emissions, primarily from fossil fuel use for energy and transport. <strong>Kazakhstan</strong> and <strong>Russia</strong> show lower emissions than the Gulf states and Western nations, but still exceed the global average. Meanwhile, <strong>Luxembourg</strong> maintains high emissions due to its industrial economy, while <strong>Palau</strong> stands out with lower emissions, thanks to its focus on tourism over heavy industry.</p>
<p></p>
<!-- BarPlot that show the emission and the country in one decade (2011 to 2022) -->
<br>
<h3 id="top-20-countries-with-high-co-emissions-per-capita-in-nearest-decade-2011-to-2022" tabindex="-1"><a class="observablehq-header-anchor" href="#top-20-countries-with-high-co-emissions-per-capita-in-nearest-decade-2011-to-2022">Top 20 Countries with high COâ‚‚ Emissions Per Capita in nearest decade (2011 to 2022) ðŸŒ</a></h3>
<div class="observablehq observablehq--block"><!--:ce8e7431:--></div>
<div class="grid grid-cols-1"> 
  <div class="card"> <observablehq-loading></observablehq-loading><!--:a24953ee:--> </div> 
</div>
<p>
</p><p>From 2011 to 2022, countries like <strong>Qatar</strong>, <strong>Bahrain</strong>, and <strong>Kuwait</strong> consistently ranked at the top for COâ‚‚ emissions per capita, largely due to their heavy reliance on fossil fuel extraction and small, energy-intensive economies.</p>
<p><strong>Australia</strong>, <strong>United States</strong>, and <strong>Canada</strong> follow closely, with emissions driven by large industrial sectors and energy needs for vast geographical areas. While these countries are larger and more industrialized, their high consumption patterns still make their per capita emissions relatively high compared to global averages.</p>
<p>Meanwhile, <strong>Luxembourg</strong> and <strong>Faroe Islands</strong> stand out for their relatively high per capita emissions despite their small sizes.</p>
<p>In contrast, <strong>Palau</strong> shows a much lower carbon footprint. Its small population and tourism-based economy, which doesnâ€™t rely on heavy industry, allow it to maintain one of the lowest per capita emissions on the list.</p>
<p>Overall, the data highlights a clear link between fossil fuel reliance, industrial activity, and high COâ‚‚ emissions, while also showing how small nations with less industrialization can maintain lower per capita emissions.</p>
<p></p>
<br>
<h2 id="country-comparison-per-region-in-2022" tabindex="-1"><a class="observablehq-header-anchor" href="#country-comparison-per-region-in-2022">Country Comparison per Region in 2022</a></h2>
<br>
<h3 id="region-with-high-co-emissions" tabindex="-1"><a class="observablehq-header-anchor" href="#region-with-high-co-emissions">Region with high COâ‚‚ Emissions ðŸŒ</a></h3>
<div class="observablehq observablehq--block"><!--:0ce1d9a3:--></div>
<div class="grid grid-cols-1">
  <div class="card"> <observablehq-loading></observablehq-loading><!--:0f6b3f90:--> </div>
</div>
<p>
</p><p>In 2022, global COâ‚‚ emissions were dominated by key countries across regions.
<strong>China</strong> remains the worldâ€™s largest emitter, largely due to its vast manufacturing sector, reliance on coal, and the energy demands of its massive population. <strong>India</strong>, while having a lower per capita emission than China, continues to see rapid industrial growth and energy consumption, particularly in urban areas.</p>
<p>In North America, <strong>the USA</strong> continues to be a major emitter with emissions largely driven by energy consumption, transportation, and industrial sectors. <strong>Canada</strong>, with its vast landmass and reliance on energy-intensive industries like oil extraction, also ranks high in emissions per capita.</p>
<p><strong>Russia</strong> stands as Europeâ€™s largest emitter, with emissions driven by its oil and natural gas extraction industries. <strong>Germany</strong>, Europeâ€™s industrial powerhouse, also contributes heavily, particularly through manufacturing, transportation, and energy sectors.</p>
<p><strong>South Africa</strong> and <strong>Egypt</strong> are the top emitters in Africa. <strong>South Africaâ€™s</strong> emissions are largely from coal-powered energy production, while <strong>Egypt</strong> has seen increasing emissions due to urbanization and energy demands.</p>
<p>In South America, <strong>Brazil</strong>â€™s emissions are shaped by deforestation, agriculture, and energy consumption, while <strong>Argentina</strong> also experiences high emissions due to its industrial sector and large-scale agriculture.</p>
<p><strong>Australia</strong> and <strong>New Zealand</strong> contribute heavily to emissions in Oceania, with <strong>Australia</strong>'s reliance on coal for energy and high per capita car usage. <strong>New Zealand</strong>, despite having a smaller population, has significant emissions from agriculture, particularly livestock.</p>
<p></p>
<br>
<h3 id="top-3-co-emitters-per-capita-per-region" tabindex="-1"><a class="observablehq-header-anchor" href="#top-3-co-emitters-per-capita-per-region">Top 3 COâ‚‚ emitters per capita per region ðŸŒ</a></h3>
<div class="observablehq observablehq--block"><!--:e764d8c5:--></div>
<div class="grid grid-cols-1">
  <div class="card"><observablehq-loading></observablehq-loading><!--:2832f044:--></div>
</div>
<p>
</p><p>In the previous chart we can visualize the top three COâ‚‚ emitters from each region in 2022, highlighting key trends in energy consumption and industrialization.</p>
<p>In the top emitters per region, the <strong>USA</strong> stands out as the largest emitter globally, with its massive industrial base, transportation sector, and high energy consumption. Following closely, <strong>India</strong> and <strong>Germany</strong> are the second largest emitters in their respective regions, driven by industrial activities and energy demands. <strong>Japan</strong> and the <strong>UK</strong> round out the third positions, reflecting their energy-intensive economies and reliance on fossil fuels, though Japan's emissions remain high due to its significant manufacturing sector.</p>
<p>This analysis suggests that <strong>Asia</strong> and <strong>Europe</strong> are the regions with the largest concentrations of emissions, with major contributors like the <strong>USA</strong>, <strong>India</strong>, and <strong>Germany</strong> leading the way. Their high emissions stem from a mix of industrialization, transportation, and energy production needs, showing a clear pattern where both population size and industrial output play crucial roles in regional COâ‚‚ emissions.</p>
<p></p>
<br>
<!-- Percentage of first graph rappresentation-->
<h3 id="region-with-high-co-percentage-emissions" tabindex="-1"><a class="observablehq-header-anchor" href="#region-with-high-co-percentage-emissions">Region with high COâ‚‚ Percentage Emissions ðŸŒ</a></h3>
<div class="observablehq observablehq--block"><!--:c3c0d68d:--></div>
<div class="grid grid-cols-1">
  <div class="card"> <observablehq-loading></observablehq-loading><!--:f17805dc:--> </div>
</div>
<p>
</p><p>In Asia, <strong>China</strong> is responsible for 52.18% of the region's COâ‚‚ emissions, highlighting its role as the largest emitter in the world. In <strong>North America</strong>, the <strong>USA</strong> accounts for a staggering 80.27% of emissions, driven by its high energy consumption, transportation sector, and industrial activities. In <strong>Europe</strong>, <strong>Russia</strong> contributes 32.57% of emissions, with <strong>Germany</strong> following at 13.26%, reflecting their large industrial bases and energy needs.</p>
<p>In <strong>Africa</strong>, <strong>South Africa</strong> is the leading emitter with 29.19%, while <strong>Egypt</strong> contributes 17.45%. <strong>Brazil</strong> accounts for 44.39% of <strong>South America's</strong> emissions, with <strong>Argentina</strong> contributing 17.96%. In <strong>Oceania</strong>, <strong>Australia</strong> dominates, responsible for 89.06% of the region's emissions.</p>
<p></p>
<br>
<h2 id="co-emissions-comparison-per-type-fossil-land-use" tabindex="-1"><a class="observablehq-header-anchor" href="#co-emissions-comparison-per-type-fossil-land-use">COâ‚‚ emissions comparison per type (fossil/land-use)</a></h2>
<br>
<h3 id="co-emissions-heatmap" tabindex="-1"><a class="observablehq-header-anchor" href="#co-emissions-heatmap">COâ‚‚ Emissions Heatmap ðŸŒ</a></h3>
<div class="observablehq observablehq--block"><!--:398d36ac:--></div>
<div class="grid grid-cols-1"> 
  <div class="card">
    <div id="dropdown-container" style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-bottom: 10px;">
      <span>Select a year to view COâ‚‚ emissions by country:</span> 
      <select id="year-dropdown"></select> <!-- Dropdown for years -->
      <button id="auto-play-button">Auto Play</button> <!-- Auto Play button -->
    </div>
    <div id="heatmap-container"></div>
  </div> 
</div>
<p>
</p><p>The heatmap visually represents the share of COâ‚‚ emissions coming from <em>fossil fuels</em> versus <em>land-use changes</em> across different countries. In this heatmap, regions where <em>fossil fuel emissions</em> dominate are shown with deeper shades of red, indicating a higher contribution to total emissions from industries such as energy production, transportation, and manufacturing. On the other hand, areas where <em>land-use emissions</em>, such as deforestation and agriculture, play a larger role are highlighted in shades of green, indicating their significant impact on global COâ‚‚ levels due to land transformation and vegetation loss.</p>
<p>Countries with large industrial economies and high energy consumption, such as the <strong>USA</strong>, <strong>China</strong>, and <strong>India</strong>, dominate the red spectrum. These nations rely heavily on fossil fuels for electricity, heating, transportation, and manufacturing, driving the bulk of their emissions from these sources. <strong>Europe</strong> also shows significant fossil fuel emissions, particularly in industrialized nations like <strong>Germany</strong> and <strong>Russia</strong>.</p>
<p>Countries with significant land-use emissions are those with large agricultural sectors or high rates of deforestation. <strong>Brazil</strong> stands out in South America, where deforestation of the Amazon contributes massively to carbon emissions. Similarly, <strong>Indonesia</strong> also shows strong land-use emissions. These emissions primarily result from agricultural practices, land clearing for agriculture, and changes in forest cover.</p>
<p>This heatmap reveals a global landscape where <strong>fossil fuel consumption</strong> is the dominant source of emissions in highly industrialized countries, whereas <strong>land-use changes</strong> emerge as a major source in regions with extensive agricultural practices or deforestation. Understanding the distribution of these emission types is crucial for shaping climate policies, as addressing fossil fuel emissions may require different strategies than tackling emissions from land-use changes.</p>
<p></p>
<h1 id="section-2-alluvial" tabindex="-1"><a class="observablehq-header-anchor" href="#section-2-alluvial">Section 2: Alluvial</a></h1>
<br>
<h2 id="data-and-chart-setup" tabindex="-1"><a class="observablehq-header-anchor" href="#data-and-chart-setup">Data and Chart Setup</a></h2>
<div class="observablehq observablehq--block"><!--:7c4f44f2:--></div>
<div class="grid grid-cols-1"> 
  <div class="card"> <observablehq-loading></observablehq-loading><!--:40e98c05:--></div> 
</div>
<p>
</p><p>This chart offers a detailed visualization of COâ‚‚ emissions for the year 2022, providing valuable insights into the primary sources of global COâ‚‚ emissions.</p>
<p>Each continentâ€™s total COâ‚‚ emissions are represented by flows, with larger flows indicating greater emissions.</p>
<p>Emission flows split further to individual countries. More significant flows indicate higher national emissions.
Major emitters like the <strong>United States</strong>, <strong>China</strong>, and <strong>Brazil</strong> dominate the chart, reflecting their status as some of the largest contributors to global COâ‚‚ emissions.</p>
<p>The chart divides emissions into two primary categories on the right: <strong>Fossil Fuel Use</strong> and <strong>Land Use</strong>.
Countries such as the <strong>United States</strong> and <strong>China</strong> show significant flows linked to <strong>Fossil Fuel Use</strong>, highlighting their dependence on coal, oil, and natural gas.
In contrast, nations like <strong>Brazil</strong> and other countries in South America exhibit stronger connections to <strong>Land Use</strong> emissions, reflecting the impact of deforestation and land management practices.</p>
<p><strong>Indonesia</strong> and <strong>Russia</strong> also contribute significantly to global emissions, though their flows are smaller compared to top emitters like the U.S. and China.</p>
<p></p>
<h1 id="co-emissions-map" tabindex="-1"><a class="observablehq-header-anchor" href="#co-emissions-map">COâ‚‚ Emissions Map ðŸŒ</a></h1>
<h2 id="plot-1" tabindex="-1"><a class="observablehq-header-anchor" href="#plot-1">Plot 1</a></h2>
<div class="observablehq observablehq--block"><!--:6530913e:--></div>
<div id="chart-container" style="width: 100%; height: 600px;"></div>
<p>
sa
</p>
<h2 id="plot-2" tabindex="-1"><a class="observablehq-header-anchor" href="#plot-2">Plot 2</a></h2>
<div class="observablehq observablehq--block"><!--:ad3a78a4:--></div>
<div id="chart-container" style="width: 40%; height: 500px;"></div>
<p>
sa sa
</p>
</main>
<footer id="observablehq-footer">
<nav><a rel="prev" href="./"><span>DataVisualization</span></a></nav>
<div>Built with <a href="https://observablehq.com/" target="_blank" rel="noopener noreferrer">Observable</a> on <a title="2024-11-22T10:26:11">Nov 22, 2024</a>.</div>
</footer>
</div>
</body>
</html>
