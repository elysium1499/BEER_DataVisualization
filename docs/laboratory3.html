<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="generator" content="Observable Framework v1.13.0">
<title>Don&#x27;t get confused by maps | CO₂ emissions</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="preload" as="style" href="./_observablehq/theme-air,near-midnight,alt,wide.db1cdf55.css">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="stylesheet" type="text/css" href="./_observablehq/theme-air,near-midnight,alt,wide.db1cdf55.css">
<link rel="modulepreload" href="./_observablehq/client.7782eb36.js">
<link rel="modulepreload" href="./_observablehq/runtime.9393ab6d.js">
<link rel="modulepreload" href="./_observablehq/stdlib.3ee9cb94.js">
<link rel="modulepreload" href="./_node/d3-geo@3.1.1/index.75f0ca91.js">
<link rel="modulepreload" href="./_node/d3-scale@4.0.2/index.61617510.js">
<link rel="modulepreload" href="./_node/d3-scale-chromatic@3.1.0/index.7961cbed.js">
<link rel="modulepreload" href="./_node/d3-zoom@3.0.0/index.0e732a91.js">
<link rel="modulepreload" href="./_npm/d3@7.9.0/7055d4c5.js">
<link rel="modulepreload" href="./_npm/d3-dsv@3.0.1/407f7a1f.js">
<link rel="modulepreload" href="./_node/d3-array@3.2.4/index.f89e3560.js">
<link rel="modulepreload" href="./_node/d3-interpolate@3.0.1/index.7ed7c7fe.js">
<link rel="modulepreload" href="./_node/d3-format@3.1.0/index.75f84505.js">
<link rel="modulepreload" href="./_node/d3-time@3.1.0/index.8fcc123e.js">
<link rel="modulepreload" href="./_node/d3-time-format@4.1.0/index.20c5f3ca.js">
<link rel="modulepreload" href="./_node/d3-color@3.1.0/index.e8c126ff.js">
<link rel="modulepreload" href="./_node/d3-dispatch@3.0.1/index.be49ca5f.js">
<link rel="modulepreload" href="./_node/d3-drag@3.0.0/index.8e5f73cc.js">
<link rel="modulepreload" href="./_node/d3-selection@3.0.0/index.13204b25.js">
<link rel="modulepreload" href="./_node/d3-transition@3.0.1/index.d140d658.js">
<link rel="modulepreload" href="./_npm/d3-array@3.2.4/e95f898e.js">
<link rel="modulepreload" href="./_npm/d3-axis@3.0.0/d44feff9.js">
<link rel="modulepreload" href="./_npm/d3-brush@3.0.0/5830b12a.js">
<link rel="modulepreload" href="./_npm/d3-chord@3.0.1/84d7b8e9.js">
<link rel="modulepreload" href="./_npm/d3-color@3.1.0/2c0cdfa2.js">
<link rel="modulepreload" href="./_npm/d3-contour@4.0.2/626bedc4.js">
<link rel="modulepreload" href="./_npm/d3-delaunay@6.0.4/00c41b5d.js">
<link rel="modulepreload" href="./_npm/d3-dispatch@3.0.1/b5f7cdc6.js">
<link rel="modulepreload" href="./_npm/d3-drag@3.0.0/b22c5864.js">
<link rel="modulepreload" href="./_npm/d3-ease@3.0.1/6f15f633.js">
<link rel="modulepreload" href="./_npm/d3-fetch@3.0.1/ef1ec490.js">
<link rel="modulepreload" href="./_npm/d3-force@3.0.0/5e1ff060.js">
<link rel="modulepreload" href="./_npm/d3-format@3.1.0/5851d7ef.js">
<link rel="modulepreload" href="./_npm/d3-geo@3.1.1/dcd02767.js">
<link rel="modulepreload" href="./_npm/d3-hierarchy@3.1.2/f1db2593.js">
<link rel="modulepreload" href="./_npm/d3-interpolate@3.0.1/034b7bcb.js">
<link rel="modulepreload" href="./_npm/d3-path@3.1.0/4bb53638.js">
<link rel="modulepreload" href="./_npm/d3-polygon@3.0.1/bbafde58.js">
<link rel="modulepreload" href="./_npm/d3-quadtree@3.0.1/aa5b35a8.js">
<link rel="modulepreload" href="./_npm/d3-random@3.0.1/32c7fec2.js">
<link rel="modulepreload" href="./_npm/d3-scale@4.0.2/567840a0.js">
<link rel="modulepreload" href="./_npm/d3-scale-chromatic@3.1.0/cf9b720b.js">
<link rel="modulepreload" href="./_npm/d3-selection@3.0.0/5dcd62f4.js">
<link rel="modulepreload" href="./_npm/d3-shape@3.2.0/f8e03c56.js">
<link rel="modulepreload" href="./_npm/d3-time@3.1.0/5bc129e1.js">
<link rel="modulepreload" href="./_npm/d3-time-format@4.1.0/19c92b44.js">
<link rel="modulepreload" href="./_npm/d3-timer@3.0.1/f31b5398.js">
<link rel="modulepreload" href="./_npm/d3-transition@3.0.1/8debb4ba.js">
<link rel="modulepreload" href="./_npm/d3-zoom@3.0.0/4b0cc581.js">
<link rel="modulepreload" href="./_node/internmap@2.0.3/index.4106013c.js">
<link rel="modulepreload" href="./_node/d3-timer@3.0.1/index.0ee6092b.js">
<link rel="modulepreload" href="./_node/d3-ease@3.0.1/index.09153f73.js">
<link rel="modulepreload" href="./_npm/internmap@2.0.3/5eed35fd.js">
<link rel="modulepreload" href="./_npm/delaunator@5.0.1/e67acb27.js">
<link rel="modulepreload" href="./_npm/robust-predicates@3.0.2/8ac9039b.js">
<link rel="icon" href="./_file/observable.1af93621.png" type="image/png" sizes="32x32">
<script type="module">

import {define} from "./_observablehq/client.7782eb36.js";
import {registerFile} from "./_observablehq/stdlib.3ee9cb94.js";

registerFile("./data/co-emissions-per-capita-filter.csv", {"name":"./data/co-emissions-per-capita-filter.csv","mimeType":"text/csv","path":"./_file/data/co-emissions-per-capita-filter.9f9ae678.csv","lastModified":1731700104052,"size":179331});
registerFile("./data/region_entities_population2022.csv", {"name":"./data/region_entities_population2022.csv","mimeType":"text/csv","path":"./_file/data/region_entities_population2022.444e37a4.csv","lastModified":1732613650930,"size":5854});

define({id: "2dfae63a", inputs: ["d3","width"], outputs: ["countryNameMapping","createTooltip","geoMercator","geoEqualEarth","geoAzimuthalEqualArea","geoPath","scaleSequential","scaleQuantile","interpolateYlOrRd","zoom","getEmissionsWithPopulation","getEmissionsData","updateLegend","insertZoomHandler"], body: async (d3,width) => {
const [{geoMercator, geoEqualEarth, geoAzimuthalEqualArea, geoPath}, {scaleSequential, scaleQuantile}, {interpolateYlOrRd}, {zoom}] = await Promise.all([import("./_node/d3-geo@3.1.1/index.75f0ca91.js"), import("./_node/d3-scale@4.0.2/index.61617510.js"), import("./_node/d3-scale-chromatic@3.1.0/index.7961cbed.js"), import("./_node/d3-zoom@3.0.0/index.0e732a91.js")]);
const countryNameMapping = {
    "USA": "United States",
    "England": "United Kingdom",
    "Czech Republic": "Czechia",
    "Republic of Serbia": "Serbia",
    "Guinea Bissau": "Guinea-Bissau",
    "Macedonia": "North Macedonia",
    "Ivory Coast": "Cote d'Ivoire",
    "Somaliland": "Somalia",
    "Republic of the Congo": "Congo",
    "Democratic Republic of the Congo": "Congo",
    "United Republic of Tanzania": "Tanzania",
    "The Bahamas": "Bahamas"
};

function createTooltip(id) {
  return d3.select("body").append("div")
    .attr("id", id)
    .attr("class", "tooltip")
    .style("position", "absolute")
    .style("background", "rgba(0, 0, 0, 0.7)")
    .style("color", "white")
    .style("padding", "5px 10px")
    .style("border-radius", "4px")
    .style("font-size", "12px")
    .style("pointer-events", "none")
    .style("display", "none")
    .style("z-index", "10"); 
}



async function getEmissionsWithPopulation(co_emissions_per_capita, region_population, countryNameMapping) {

  const populationMap = new Map(region_population.map(d => [d.Entity, d.Population2022]));

  const emissionsWithPopulation = co_emissions_per_capita.filter(d => d.Year === 2022).map(d => {
    let countryName = d.Entity;
    countryName = countryNameMapping[countryName] || countryName;

    const population = populationMap.get(countryName);
    const totalEmissions = population ? d["Annual CO₂ emissions (per capita)"] * population : null;

    return {...d, Population: population, TotalEmissions: totalEmissions};
  });
  return emissionsWithPopulation;
}

async function getEmissionsData(co_emissions_per_capita) {
  const emissionsData = co_emissions_per_capita.filter(d => d.Year === 2022).map(d => ({
    Entity: d.Entity,
    Emissions: d["Annual CO₂ emissions (per capita)"],
  }));

  return emissionsData;
}


function updateLegend(legendRectWidth, legendRectHeight, legendGroup, legendSpacing, minEmission, quantileValues, maxEmission, colorScale, customFormat) {
  const quantileBreaks = [minEmission, ...quantileValues, maxEmission];

  legendGroup.selectAll("*").remove();

  // Calculate the number of columns based on width
  const numColumns = Math.floor(width / (legendRectWidth + legendSpacing));
  const numRows = Math.ceil(quantileBreaks.length / numColumns);

  // Adjust legend position to make room for multiple rows
  legendGroup.attr("transform", `translate(50, ${30})`);

  // Create legend rectangles
  legendGroup.selectAll("rect")
    .data(quantileBreaks.slice(0, -1))
    .join("rect")
    .attr("x", (d, i) => (i % numColumns) * (legendRectWidth + legendSpacing))
    .attr("y", (d, i) => Math.floor(i / numColumns) * (legendRectHeight + 15))
    .attr("width", legendRectWidth+10)
    .attr("height", legendRectHeight)
    .style("fill", (d, i) => colorScale(d));

  // Create legend text labels
  legendGroup.selectAll("text")
    .data(quantileBreaks.slice(0, -1))
    .join("text")
    .attr("x", (d, i) => (i % numColumns) * (legendRectWidth + legendSpacing) + legendRectWidth / 2 +5)
    .attr("y", (d, i) => Math.floor(i / numColumns) * (legendRectHeight + 15) + legendRectHeight + 12)
    .attr("text-anchor", "middle")
    .style("fill", "white")
    .style("font-size", "9px")
    .text((d, i) => {
      const lower = quantileBreaks[i];
      const upper = quantileBreaks[i + 1];
      return `${customFormat(lower)} - ${customFormat(upper)}`;
    });
}

function insertZoomHandler(mapGroup, height){
  return d3.zoom().scaleExtent([1, 8]).translateExtent([[-width, -height], [2 * width, 2 * height]]).on("zoom", (event) => {
    mapGroup.attr("transform", event.transform);
  });
}

return {countryNameMapping,createTooltip,geoMercator,geoEqualEarth,geoAzimuthalEqualArea,geoPath,scaleSequential,scaleQuantile,interpolateYlOrRd,zoom,getEmissionsWithPopulation,getEmissionsData,updateLegend,insertZoomHandler};
}});

define({id: "b1e195df", inputs: ["FileAttachment","getEmissionsWithPopulation","countryNameMapping","d3","createTooltip","insertZoomHandler","updateLegend"], outputs: ["createCO2EmissionsMapWorld"], body: (FileAttachment,getEmissionsWithPopulation,countryNameMapping,d3,createTooltip,insertZoomHandler,updateLegend) => {
async function createCO2EmissionsMapWorld(containerId, customPercentiles = [0.25, 0.5, 0.75, 0.95]) {
  const co_emissions_per_capita = await FileAttachment("./data/co-emissions-per-capita-filter.csv").csv({ typed: true });
  const region_population = await FileAttachment("./data/region_entities_population2022.csv").csv({ typed: true });

 const emissionsWithPopulation = await getEmissionsWithPopulation(co_emissions_per_capita, region_population, countryNameMapping);

  const topEmissions = emissionsWithPopulation.sort((a, b) => (b.TotalEmissions || 0) - (a.TotalEmissions || 0));

  const url = "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson";
  const worldData = await fetch(url).then(response => response.json());

  const emissionMap = new Map(topEmissions.map(d => [d.Entity, d.TotalEmissions]));

  const countriesWithEmissions = worldData.features.map(feature => {
    let countryName = feature.properties.name;
    countryName = countryNameMapping[countryName] || countryName;

    const emission = emissionMap.get(countryName);
    feature.properties.emission = emission;
    return feature;
  });

  const container = d3.select("#" + containerId);

  // Resize dynamically based on container
  const width = container.node().clientWidth;
  const height = container.node().clientHeight;

  const projection = d3.geoMercator()
    .scale(100)
    .translate([width / 2, height / 1.5]);

  const path = d3.geoPath().projection(projection);

  const minEmission = d3.min(topEmissions, d => d.TotalEmissions || 0);
  const maxEmission = d3.max(topEmissions, d => d.TotalEmissions);

  const quantileValues = customPercentiles.map(p =>
    d3.quantile(topEmissions.map(d => d.TotalEmissions).filter(d => d != null), p)
  );

  quantileValues.unshift(minEmission);
  quantileValues.push(maxEmission);

  quantileValues.sort((a, b) => a - b);

  const colorScale = d3.scaleQuantile()
    .domain(quantileValues)
    .range([
      "#ffffe0", "#fffb80", "#fff566", "#ffed3e", "#ffdb2d", "#ffcc00",
      "#ffaa00", "#ff8c00", "#ff7300", "#ff5722", "#e64a19", "#d32f2f",
      "#c62828", "#b71c1c"
    ]);

  const svg = container.append("svg")
    .attr("width", width)
    .attr("height", height);

  const mapGroup = svg.append("g");

  function customFormat(value) {
    if (value >= 1e9) {
      return (value / 1e9).toFixed(2) + " Bt";
    } else if (value >= 1e6) {
      return (value / 1e6).toFixed(2) + " Mt";
    } else {
      return value.toFixed(2) + " t";
    }
  }

  const tooltip = createTooltip("tooltip3");
  
  mapGroup.selectAll("path")
    .data(countriesWithEmissions)
    .join("path")
    .attr("d", path)
    .attr("fill", d => {
      const emissions = d.properties.emission;
      return emissions ? colorScale(emissions) : "#ccc";
    })
    .attr("stroke", "white")
    .attr("stroke-width", 0.5)
    .on("mouseover", (event, d) => {
      const emissions = d.properties.emission;
      tooltip.style("display", "block")
        .style("opacity", 1)
        .html(`<strong>${d.properties.name}</strong><br>
             Emissions: ${emissions ? customFormat(emissions) : "No data"}`);
    })
    .on("mousemove", (event) => {
      tooltip.style("left", (event.pageX + 10) + "px")
             .style("top", (event.pageY - 10) + "px");
    })
    .on("mouseout", () => {
      tooltip.style("display", "none");
    });

  svg.call(insertZoomHandler(mapGroup, height));

  const legendGroup = svg.append("g")
    .attr("transform", `translate(50, 30)`);

  const legendRectWidth = 70;
  const legendRectHeight = 20;
  const legendSpacing = 20;

  // Initial legend rendering
  updateLegend(legendRectWidth, legendRectHeight, legendGroup, legendSpacing, minEmission, quantileValues, maxEmission, colorScale, customFormat);

  // Handle window resizing
  window.addEventListener("resize", () => {
    const width = container.node().clientWidth;
    const height = container.node().clientHeight;
    svg.attr("width", width).attr("height", height);
    projection.translate([width / 2, height / 2]);
    mapGroup.selectAll("path").attr("d", path);
    updateLegend();
  });
}

createCO2EmissionsMapWorld("MapOnechart");

return {createCO2EmissionsMapWorld};
}});

define({id: "59fa8fd7", inputs: ["FileAttachment","getEmissionsWithPopulation","countryNameMapping","d3","createTooltip","insertZoomHandler","updateLegend"], outputs: ["createCO2EmissionsMapEarth"], body: (FileAttachment,getEmissionsWithPopulation,countryNameMapping,d3,createTooltip,insertZoomHandler,updateLegend) => {
async function createCO2EmissionsMapEarth(containerId) {
  // Load datasets
  const co_emissions_per_capita = await FileAttachment("./data/co-emissions-per-capita-filter.csv").csv({ typed: true });
  const region_population = await FileAttachment("./data/region_entities_population2022.csv").csv({ typed: true });

  // Transform the population dataset into a map
  const populationMap = new Map(region_population.map(d => [d.Entity, d.Population2022]));

  // Calculate total emissions for each country
  const emissionsWithPopulation = await getEmissionsWithPopulation(co_emissions_per_capita, region_population, countryNameMapping);

  // Sort countries by total emissions
  const topEmissions = emissionsWithPopulation.sort((a, b) => (b.TotalEmissions || 0) - (a.TotalEmissions || 0));

  // Calculate percentiles and create a discrete color scale
  const customPercentiles = [0.25, 0.5, 0.75, 0.95];
  const quantileValues = customPercentiles.map(p =>
    d3.quantile(topEmissions.map(d => d.TotalEmissions).filter(d => d != null), p)
  );
  const minEmission = d3.min(topEmissions, d => d.TotalEmissions);
  const maxEmission = d3.max(topEmissions, d => d.TotalEmissions);

  quantileValues.unshift(minEmission);
  quantileValues.push(maxEmission);

  const colorScale = d3.scaleQuantile()
    .domain(quantileValues)
    .range([
      "#ffffe0", "#fffb80", "#fff566", "#ffed3e", "#ffdb2d", "#ffcc00",
      "#ffaa00", "#ff8c00", "#ff7300", "#ff5722", "#e64a19", "#d32f2f",
      "#c62828", "#b71c1c"
    ]);

  // URL of GeoJSON file
  const url = "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson";
  const worldData = await fetch(url).then(response => response.json());

  // Create a map of total emissions
  const emissionMap = new Map(topEmissions.map(d => [d.Entity, d.TotalEmissions]));

  // Update GeoJSON with emission data
  const countriesWithEmissions = worldData.features.map(feature => {
    let countryName = feature.properties.name;
    countryName = countryNameMapping[countryName] || countryName;

    const emission = emissionMap.get(countryName);
    feature.properties.totalEmission = emission;
    return feature;
  });

  // Container dimensions
  const container = d3.select("#" + containerId);
  const width = container.node().clientWidth;
  const height = container.node().clientHeight;

  // Projection and path (Mercator projection)
  const projection = d3.geoOrthographic()
    .scale(150)
    .translate([(width / 2), height / 2]);
  const path = d3.geoPath().projection(projection);

  // Create SVG and map group
  const svg = container.append("svg")
    .attr("width", width)
    .attr("height", height);

  const mapGroup = svg.append("g");

  function customFormat(value) {
    if (value >= 1e9) {
      return (value / 1e9).toFixed(2) + " Bt";
    } else if (value >= 1e6) {
      return (value / 1e6).toFixed(2) + " Mt";
    } else {
      return value.toFixed(2) + " t";
    }
  }

  const tooltip = createTooltip("tooltip2");

  mapGroup.selectAll("path")
    .data(countriesWithEmissions)
    .join("path")
    .attr("d", path)
    .attr("fill", d => {
      const emissions = d.properties.totalEmission;
      return emissions ? colorScale(emissions) : "#ccc";
    })
    .attr("stroke", "white")
    .attr("stroke-width", 0.5)
    .on("mouseover", (event, d) => {
      const emissions = d.properties.totalEmission;
      tooltip.style("display","block")
        .style("opacity", 1)
        .html(`<strong>${d.properties.name}</strong><br>
             Emissions: ${emissions ? customFormat(emissions) : "No data"}`);
    })
    .on("mousemove", (event) => {
      tooltip.style("left", (event.pageX + 10) + "px")
             .style("top", (event.pageY - 10) + "px");
    })
    .on("mouseout", () => {
      tooltip.style("display", "none");
    });

  // Drag interactions
  let lastX = 0;
  let lastY = 0;
  svg.call(d3.drag()
    .on("start", (event) => {
      lastX = event.x;
      lastY = event.y;
    })
    .on("drag", (event) => {
      const dx = event.x - lastX;
      const dy = event.y - lastY;
      const rotation = projection.rotate();
      projection.rotate([rotation[0] + dx / 2, rotation[1] - dy / 2]);
      mapGroup.selectAll("path").attr("d", path);
      lastX = event.x;
      lastY = event.y;
    })
  );

  svg.call(insertZoomHandler(mapGroup, height));

  const legendRectWidth = 70;
  const legendRectHeight = 20;
  const legendSpacing = 20;

  const legendGroup = svg.append("g")
    .attr("transform", `translate(50,30)`);  // Move legend to the top

  updateLegend(legendRectWidth, legendRectHeight, legendGroup, legendSpacing, minEmission, quantileValues, maxEmission, colorScale, customFormat);

  // Add event listener to handle window resizing
  window.addEventListener("resize", () => {
    const width = container.node().clientWidth;
    const height = container.node().clientHeight;
    svg.attr("width", width).attr("height", height);
    projection.translate([width / 2, height / 2]);
    mapGroup.selectAll("path").attr("d", path);
    updateLegend();
  });
}

// Create the map
createCO2EmissionsMapEarth("MapTwochart");

return {createCO2EmissionsMapEarth};
}});

define({id: "b51944bc", inputs: ["FileAttachment","getEmissionsData","countryNameMapping","d3","geoEqualEarth","geoPath","scaleQuantile","createTooltip","insertZoomHandler","updateLegend"], outputs: ["createCO2EmissionsMapWorld"], body: (FileAttachment,getEmissionsData,countryNameMapping,d3,geoEqualEarth,geoPath,scaleQuantile,createTooltip,insertZoomHandler,updateLegend) => {
async function createCO2EmissionsMapWorld(containerId, customPercentiles = [0.25, 0.5, 0.75, 0.95]) {
  const co_emissions_per_capita = await FileAttachment("./data/co-emissions-per-capita-filter.csv").csv({ typed: true });

  const emissionsData = await getEmissionsData(co_emissions_per_capita)

  const url = "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson";
  const worldData = await fetch(url).then(response => response.json());

  const emissionMap = new Map(emissionsData.map(d => [d.Entity, d.Emissions]));

  const countriesWithEmissions = worldData.features.map(feature => {
    let countryName = feature.properties.name;
    countryName = countryNameMapping[countryName] || countryName;

    const emission = emissionMap.get(countryName);
    feature.properties.emission = emission;
    return feature;
  });

  const container = d3.select("#" + containerId);
  const width = container.node().clientWidth;
  const height = container.node().clientHeight;

  // Using conic equidistant projection
  const projection = geoEqualEarth()
    .scale(130) // Adjust scale for better fit
    .translate([width / 2, height / 2]) // Center projection in SVG
    .center([0, 0]) // Center map at long 0, lat 20

  const path = geoPath().projection(projection);

  const minEmission = d3.min(emissionsData, d => d.Emissions || 0);
  const maxEmission = d3.max(emissionsData, d => d.Emissions);

  const quantileValues = customPercentiles.map(p =>
    d3.quantile(emissionsData.map(d => d.Emissions).filter(d => d != null), p)
  );

  quantileValues.unshift(minEmission);
  quantileValues.push(maxEmission);

  quantileValues.sort((a, b) => a - b);

  const colorScale = scaleQuantile()
    .domain(quantileValues)
    .range([
      "#ffffe0", "#fffb80", "#fff566", "#ffed3e", "#ffdb2d", "#ffcc00",
      "#ffaa00", "#ff8c00", "#ff7300", "#ff5722", "#e64a19", "#d32f2f",
      "#c62828", "#b71c1c"
    ]);

  const svg = container.append("svg")
    .attr("width", width)
    .attr("height", height);

  const mapGroup = svg.append("g");

  function customFormat(value) {
    return value ? `${value.toFixed(2)} t` : "No data";
  }

  const tooltip = createTooltip("tooltip3");

  mapGroup.selectAll("path")
    .data(countriesWithEmissions)
    .join("path")
    .attr("d", path)
    .attr("fill", d => {
      const emissions = d.properties.emission;
      return emissions ? colorScale(emissions) : "#ccc";
    })
    .attr("stroke", "white")
    .attr("stroke-width", 0.5)
    .on("mouseover", (event, d) => {
      const emissions = d.properties.emission;
      tooltip.style("display", "block")
        .style("opacity", 1)
        .html(`<strong>${d.properties.name}</strong><br>
             Emissions: ${emissions ? customFormat(emissions) : "No data"}`);
    })
    .on("mousemove", (event) => {
      tooltip.style("left", (event.pageX + 10) + "px")
             .style("top", (event.pageY - 10) + "px");
    })
    .on("mouseout", () => {
      tooltip.style("display", "none");
    });

  svg.call(insertZoomHandler(mapGroup, height));

  const legendGroup = svg.append("g")
    .attr("transform", `translate(50, 30)`);

  const legendRectWidth = 70;
  const legendRectHeight = 20;
  const legendSpacing = 20;

  updateLegend(legendRectWidth, legendRectHeight, legendGroup, legendSpacing, minEmission, quantileValues, maxEmission, colorScale, customFormat);

  // Handle window resizing
  window.addEventListener("resize", () => {
    const width = container.node().clientWidth;
    const height = container.node().clientHeight;
    svg.attr("width", width).attr("height", height);
    projection.translate([width / 2, height / 2]);
    mapGroup.selectAll("path").attr("d", path);
    updateLegend();
  });
}

createCO2EmissionsMapWorld("MapThreechart");
return {createCO2EmissionsMapWorld};
}});

define({id: "0cefcf1a", inputs: ["FileAttachment","getEmissionsData","countryNameMapping","d3","geoAzimuthalEqualArea","geoPath","scaleQuantile","createTooltip","insertZoomHandler","updateLegend"], outputs: ["createCO2EmissionsMapWorld"], body: (FileAttachment,getEmissionsData,countryNameMapping,d3,geoAzimuthalEqualArea,geoPath,scaleQuantile,createTooltip,insertZoomHandler,updateLegend) => {
async function createCO2EmissionsMapWorld(containerId, customPercentiles = [0.25, 0.5, 0.75, 0.95]) {
  const co_emissions_per_capita = await FileAttachment("./data/co-emissions-per-capita-filter.csv").csv({ typed: true });

  const emissionsData = await getEmissionsData(co_emissions_per_capita);

  const url = "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson";
  const worldData = await fetch(url).then(response => response.json());

  const emissionMap = new Map(emissionsData.map(d => [d.Entity, d.Emissions]));

  const countriesWithEmissions = worldData.features.map(feature => {
    let countryName = feature.properties.name;
    countryName = countryNameMapping[countryName] || countryName;

    const emission = emissionMap.get(countryName);
    feature.properties.emission = emission;
    return feature;
  });

  const container = d3.select("#" + containerId);
  const width = container.node().clientWidth;
  const height = container.node().clientHeight;

  // Using conic equidistant projection
  const projection = geoAzimuthalEqualArea()
    .scale(90) // Adjust scale for better fit
    .translate([width / 2, height / 2]) // Center projection in SVG
    .center([0, 0]) // Center map at long 0, lat 20

  const path = geoPath().projection(projection);

  const minEmission = d3.min(emissionsData, d => d.Emissions || 0);
  const maxEmission = d3.max(emissionsData, d => d.Emissions);

  const quantileValues = customPercentiles.map(p =>
    d3.quantile(emissionsData.map(d => d.Emissions).filter(d => d != null), p)
  );

  quantileValues.unshift(minEmission);
  quantileValues.push(maxEmission);

  quantileValues.sort((a, b) => a - b);

  const colorScale = scaleQuantile()
    .domain(quantileValues)
    .range([ 
      "#ffffe0", "#fffb80", "#fff566", "#ffed3e", "#ffdb2d", "#ffcc00",
      "#ffaa00", "#ff8c00", "#ff7300", "#ff5722", "#e64a19", "#d32f2f",
      "#c62828", "#b71c1c"
    ]);

  const svg = container.append("svg")
    .attr("width", width)
    .attr("height", height);

  const mapGroup = svg.append("g");

  function customFormat(value) {
    return value ? `${value.toFixed(2)} t` : "No data";
  }

  const tooltip = createTooltip("tooltip4");

  mapGroup.selectAll("path")
    .data(countriesWithEmissions)
    .join("path")
    .attr("d", path)
    .attr("fill", d => {
      const emissions = d.properties.emission;
      return emissions ? colorScale(emissions) : "#ccc";
    })
    .attr("stroke", "white")
    .attr("stroke-width", 0.5)
    .on("mouseover", (event, d) => {
      const emissions = d.properties.emission;
      tooltip.style("display","block")
        .style("opacity", 1)
        .html(`<strong>${d.properties.name}</strong><br>
             Emissions: ${emissions ? customFormat(emissions) : "No data"}`);
    })
    .on("mousemove", (event) => {
      tooltip.style("left", (event.pageX + 10) + "px")
             .style("top", (event.pageY - 10) + "px");
    })
    .on("mouseout", () => {
      tooltip.style("display", "none");
    });

  // Drag interactions
  let lastX = 0;
  let lastY = 0;
  svg.call(d3.drag()
    .on("start", (event) => {
      lastX = event.x;
      lastY = event.y;
    })
    .on("drag", (event) => {
      const dx = event.x - lastX;
      const dy = event.y - lastY;
      const rotation = projection.rotate();
      projection.rotate([rotation[0] + dx / 2, rotation[1] - dy / 2]);
      mapGroup.selectAll("path").attr("d", path);
      lastX = event.x;
      lastY = event.y;
    })
  );

  svg.call(insertZoomHandler(mapGroup, height));

  const legendGroup = svg.append("g")
    .attr("transform", `translate(50, 30)`);

  const legendRectWidth = 70;
  const legendRectHeight = 20;
  const legendSpacing = 20;

  updateLegend(legendRectWidth, legendRectHeight, legendGroup, legendSpacing, minEmission, quantileValues, maxEmission, colorScale, customFormat);

  // Adjust the map and legend on window resize
  window.addEventListener("resize", () => {
    const width = container.node().clientWidth;
    const height = container.node().clientHeight;
    svg.attr("width", width).attr("height", height);
    projection.translate([width / 2, height / 2]);
    mapGroup.selectAll("path").attr("d", path);
    updateLegend();
  });
}

createCO2EmissionsMapWorld("MapFourchart");
return {createCO2EmissionsMapWorld};
}});

</script>
</head>
<body>
<input id="observablehq-sidebar-toggle" type="checkbox" title="Toggle sidebar">
<label id="observablehq-sidebar-backdrop" for="observablehq-sidebar-toggle"></label>
<nav id="observablehq-sidebar">
  <ol>
    <label id="observablehq-sidebar-close" for="observablehq-sidebar-toggle"></label>
    <li class="observablehq-link"><a href="./">CO₂ emissions</a></li>
  </ol>
  <ol>
    <li class="observablehq-link"><a href="./laboratory1">Comparing countries</a></li>
    <li class="observablehq-link"><a href="./laboratory2">Fossil vs Land</a></li>
    <li class="observablehq-link observablehq-link-active"><a href="./laboratory3">Don&#x27;t get confused by maps</a></li>
    <li class="observablehq-link"><a href="./laboratory4">laboratorio 4</a></li>
  </ol>
</nav>
<script>{const e=document.querySelector("#observablehq-sidebar"),t=document.querySelector("#observablehq-sidebar-toggle"),r=sessionStorage.getItem("observablehq-sidebar");r?t.checked=r==="true":t.indeterminate=!0;for(const o of document.querySelectorAll("#observablehq-sidebar summary")){const s=o.parentElement;switch(sessionStorage.getItem(`observablehq-sidebar:${o.textContent}`)){case"true":s.open=!0;break;case"false":s.classList.contains("observablehq-section-active")||(s.open=!1);break}}addEventListener("beforeunload",()=>sessionStorage.setItem("observablehq-sidebar-scrolly",`${e.scrollTop}`));const a=sessionStorage.getItem("observablehq-sidebar-scrolly");a!=null&&(e.style.cssText="overflow: hidden;",e.scrollTop=+a,e.style.cssText="");}</script>
<div id="observablehq-center">
<aside id="observablehq-toc" data-selector="h1:not(:first-of-type)[id], h2:first-child[id], :not(h1) + h2[id]">
<nav>
<div>Contents</div>
<ol>
<li class="observablehq-secondary-link"><a href="#mercator-projection">Mercator projection</a></li>
<li class="observablehq-secondary-link"><a href="#orthografic-projection">Orthografic projection</a></li>
<li class="observablehq-secondary-link"><a href="#equal-earth-projection">Equal Earth projection</a></li>
<li class="observablehq-secondary-link"><a href="#azimuthal-equal-area-projection">Azimuthal Equal Area projection</a></li>
</ol>
</nav>
</aside>
<main id="observablehq-main" class="observablehq">
<h1 id="dont-get-confused-by-maps" tabindex="-1"><a class="observablehq-header-anchor" href="#dont-get-confused-by-maps">Don't get confused by maps 🗺️</a></h1>
<br>
<p>
</p><p>The following maps display the total CO₂ emissions of countries. While maps are a powerful tool for visualizing data, their interpretation requires caution. The choice of projection can mislead the user by overemphasizing or minimizing continents. This is especially true in cases like CO₂ emissions, where absolute emissions and per capita values paint different pictures of responsibility and impact.</p>
<p>The legends illustrate the levels of CO₂ emissions through a gradual progression of colors. At the lower end of the scale, white represents continents with the least emissions. As emissions increase, the color transitions to yellow, symbolizing moderate levels of emissions. Finally, red marks the highest emission levels.</p>
<p></p>
<h2 id="mercator-projection" tabindex="-1"><a class="observablehq-header-anchor" href="#mercator-projection">Mercator projection</a></h2>
<br>
<div class="observablehq observablehq--block"><!--:2dfae63a:--></div>
<div class="observablehq observablehq--block"><!--:b1e195df:--></div>
<div id="MapOnechart" style="width: 100%; height: 650px; margin-bottom: 50px;"></div>
<p>
</p>
<h2 id="orthografic-projection" tabindex="-1"><a class="observablehq-header-anchor" href="#orthografic-projection">Orthografic projection</a></h2>
<div class="observablehq observablehq--block"><!--:59fa8fd7:--></div>
<div id="MapTwochart" style="width: 100%; height: 500px; margin-bottom: 50px;"></div>
<p>
</p><p>In the <em>Mercator</em> projection, northern countries like the <strong>USA</strong>, <strong>Russia</strong>, and <strong>Canada</strong> are represented with inflated sizes, giving a visual impression that these continents have a disproportionately large impact on emissions. This distortion occurs because the Mercator projection stretches areas farther from the equator to maintain angular accuracy, which is useful for navigation but misleading for visualizing data distribution.</p>
<p>On the other hand, the <em>Orthographic</em> projection provides a more visually balanced representation by simulating a globe viewed from a specific perspective. While this projection reduces the distortion of landmass sizes compared to <em>Mercator</em>, it introduces its own biases. Central continents in the chosen perspective appear larger and more prominent, potentially drawing attention to their emissions while downplaying those from continents located at the periphery of the map, such as parts of <strong>Africa</strong>, <strong>South America</strong>, or <strong>Oceania</strong>. Understanding these projection biases is crucial when interpreting maps to avoid misjudging the relative contributions of different continents to CO₂ emissions.</p>
<p></p>
<br>
<p>
These maps shift the focus from absolute values to emissions normalized per person. This is crucial for understanding individual-level contributions and comparing nations with vastly different population sizes. However, here too, map distortions might confuse viewers.
</p>
<h2 id="equal-earth-projection" tabindex="-1"><a class="observablehq-header-anchor" href="#equal-earth-projection">Equal Earth projection</a></h2>
<div class="observablehq observablehq--block"><!--:b51944bc:--></div>
<div id="MapThreechart" style="width: 100%; height: 500px; margin-bottom: 50px;"></div>
<p>
</p>
<h2 id="azimuthal-equal-area-projection" tabindex="-1"><a class="observablehq-header-anchor" href="#azimuthal-equal-area-projection">Azimuthal Equal Area projection</a></h2>
<div class="observablehq observablehq--block"><!--:0cefcf1a:--></div>
<div id="MapFourchart" style="width: 100%; height: 500px; margin-bottom: 50px;"></div>
<p>
</p><p>The <em>Equal Earth</em> projection is designed to maintain area accuracy globally, ensuring that countries and continents are displayed in true proportion to their actual landmass size. This makes it a valuable tool for visualizing emissions data in terms of spatial distribution. However, its focus on equal area can inadvertently understate the significance of emissions from smaller but densely populated continents, such as urban centers or island nations. These areas might contribute significantly to global emissions per capita or in total but appear visually minor on the map.</p>
<p>The <em>Azimuthal Equal Area</em> projection, by contrast, ensures area equivalency within a localized context, making it ideal for accurately comparing the proportional size of continents. This projection allows users to center the map on a chosen focal point, which provides flexibility in focusing on specific areas. However, the choice of center inherently skews the perception of continents farther from this point. For example, a map centered on <strong>Europe</strong> will accurately display area relationships within and around <strong>Europe</strong> but may visually downplay emissions from continents such as <strong>South America</strong>, <strong>Africa</strong>, or <strong>Oceania</strong> due to their peripheral placement.
This distortion can lead to underestimating the contributions of these distant areas to global emissions. To effectively interpret this map, users should consider how the choice of center influences the visibility and perceived importance of emissions in various continents. Navigating the map to shift the center can help provide a more comprehensive understanding of emissions across different parts of the globe, reducing the potential for bias introduced by the fixed focus of static maps.</p>
<p></p></main>
<footer id="observablehq-footer">
<nav><a rel="prev" href="./laboratory2"><span>Fossil vs Land</span></a><a rel="next" href="./laboratory4"><span>laboratorio 4</span></a></nav>
<div>Built with <a href="https://observablehq.com/" target="_blank" rel="noopener noreferrer">Observable</a> on <a title="2024-12-10T18:37:17">Dec 10, 2024</a>.</div>
</footer>
</div>
</body>
</html>
